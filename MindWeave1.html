<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>MindWeave â€“ Lavagna concettuale</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Librerie per esportazione -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
      display: flex;
      flex-direction: column;
      height: 100vh;
      overflow: hidden;
    }

    header {
      flex: 0 0 auto;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 4px;
      padding: 6px 8px;
      background: #222;
      color: #f5f5f5;
      font-size: 14px;
    }

    header span.group-label {
      font-weight: 600;
      margin: 0 4px;
    }

    header input[type="text"] {
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #444;
      min-width: 120px;
      font-size: 14px;
      background: #111;
      color: #eee;
    }

    header input[type="file"] {
      font-size: 12px;
    }

    header input[type="color"] {
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
    }

    .tool-btn {
      border: 1px solid #444;
      background: #333;
      color: #eee;
      padding: 4px 6px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      min-height: 28px;
    }

    .tool-btn:hover {
      background: #444;
    }

    .tool-btn.active {
      background: #007acc;
      border-color: #00aaff;
      color: #fff;
    }

    #workspace-wrapper {
      flex: 1 1 auto;
      padding: 6px;
      overflow: auto;
      background: #ddd;
    }

    #workspace {
      position: relative;
      min-width: 800px;
      min-height: 600px;
      margin: 0 auto;
      background: #fdfdfd;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.25);
      touch-action: none;
    }

    #connectorCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .node {
      position: absolute;
      min-width: 80px;
      min-height: 40px;
      padding: 6px;
      border-radius: 6px;
      border: 2px solid #666;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      touch-action: none;
      pointer-events: auto;
    }

    .node.selected {
      box-shadow: 0 0 0 2px #007acc;
    }

    .text-node {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .node-content {
      width: 100%;
      min-height: 28px;
      outline: none;
      font-size: 14px;
      white-space: pre-wrap;       /* default: va a capo */
      word-wrap: break-word;
      text-align: center;          /* testo centrato nel riquadro */
    }

    .image-node img {
      display: block;
      max-width: 100%;
      height: auto;
      border-radius: 4px;
    }

    /* Maniglie di ridimensionamento */
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #007acc;
      border-radius: 50%;
      border: 1px solid #fff;
      box-shadow: 0 0 0 1px #007acc;
      touch-action: none;
    }

    .resize-handle.tl {
      top: -6px;
      left: -6px;
      cursor: nwse-resize;
    }

    .resize-handle.tr {
      top: -6px;
      right: -6px;
      cursor: nesw-resize;
    }

    .resize-handle.bl {
      bottom: -6px;
      left: -6px;
      cursor: nesw-resize;
    }

    .resize-handle.br {
      bottom: -6px;
      right: -6px;
      cursor: nwse-resize;
    }

    #status-bar {
      flex: 0 0 auto;
      padding: 4px 8px;
      background: #111;
      color: #ccc;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      header {
        font-size: 12px;
      }
      .tool-btn {
        font-size: 12px;
        padding: 3px 4px;
      }
      header input[type="text"] {
        min-width: 100px;
      }
    }
  </style>
</head>
<body>
  <header>
    <span class="group-label">Testo:</span>
    <input type="text" id="textInput" placeholder="Scrivi testo nodo" />
    <button class="tool-btn" id="addTextBtn">ðŸ…£+</button>
    <button class="tool-btn" id="toggleWrapBtn" title="Testo a capo ON/OFF">â†” testo</button>

    <span class="group-label">Immagine:</span>
    <input type="file" id="imageInput" accept="image/*" />
    <button class="tool-btn" id="addImageBtn">ðŸ–¼+</button>

    <span class="group-label">Nodo:</span>
    <button class="tool-btn" id="resizeModeBtn">ðŸ”³ Resize</button>
    <button class="tool-btn" id="nodePlusBtn">â–¡+</button>
    <button class="tool-btn" id="nodeMinusBtn">â–¡âˆ’</button>

    <span class="group-label">Connettori:</span>
    <button class="tool-btn" id="connectorModeBtn">â–¡â†’â–¡</button>

    <span class="
group-label">Frecce:</span>
    <button class="tool-btn" id="arrowModeBtn">âžœ</button>
    <button class="tool-btn" id="arrowLengthPlusBtn">â†”+</button>
    <button class="tool-btn" id="arrowLengthMinusBtn">â†”âˆ’</button>
    <button class="tool-btn" id="arrowRotateLeftBtn">ðŸ”„âˆ’</button>
    <button class="tool-btn" id="arrowRotateRightBtn">ðŸ”„+</button>

    <span class="group-label">Colori:</span>
    <label title="Bordo nodo">ðŸ–¼</label><input type="color" id="borderColorPicker" value="#666666" />
    <label title="Testo nodo">A</label><input type="color" id="textColorPicker" value="#000000" />
    <label title="Freccia">â†’</label><input type="color" id="arrowColorPicker" value="#0000ff" />

    <span class="group-label">Livello:</span>
    <button class="tool-btn" id="bringToFrontBtn" title="Porta
 in primo piano">â¬† Primo</button>
    <button class="tool-btn" id="sendToBackBtn" title="Manda dietro">â¬‡ Dietro</button>

    <span class="group-label">Azioni:</span>
    <!-- PNG standard + PNG HQ -->
    <button class="tool-btn" id="savePngStandardBtn">ðŸ“¸ PNG</button>
    <button class="tool-btn" id="savePngHQBtn" title="PNG qualitÃ  massima">ðŸ“¸ PNG HQ</button>
    <button class="tool-btn" id="savePdfBtn">ðŸ“„ PDF</button>
    <button class="tool-btn" id="deleteSelectedBtn">ðŸ—‘ Cancella</button>
    <button class="tool-btn" id="clearAllBtn">ðŸ§¹ Tutto</button>
    <button class="tool-btn" id="saveBoardBtn">ðŸ’¾ Salva</button>
    <button class="tool-btn" id="loadBoardBtn">ðŸ“‚ Apri</button>
    <input type="file" id="loadBoardInput" accept=".json" style="display:none" />
  </header>

  <div id="workspace-wrapper">
    <div id="workspace">
      <canvas id="connectorCanvas"></canvas>
      <!-- Nodi creati dinamicamente -->
    </div>
  </div>

  <div id="status-bar">ModalitÃ : normale</div>

  <script>
    // =========================
    // Stato globale
    // =========================
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('connectorCanvas');
    const ctx = canvas.getContext('2d');

    let mode = 'normal'; // 'normal', 'connector', 'arrow', 'resizeNode'
    let nodes = [];       // {id, el, type, x, y, z}
    let connectors = [];  // {id, fromId, toId, color, z}
    let freeArrows = [];  // {id, cx, cy, length, angle, color, z}
    let nextId = 1;

    let selectedNodeId = null;
    let selectedConnectorId = null;
    let selectedFreeArrowId = null;

    let connectorStartNodeId = null;

    let draggingNode = null;
    let dragNodePointerId = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    let resizingNode = null;
    let resizeCorner = null;
    let resizeStart = null; // {x,y,width,height,left,top,aspect}

    let drawingArrowStart = null; // {x,y}

    let draggingFreeArrowId = null;
    let dragArrowStart = null; // {pointerX, pointerY, cx, cy}
    let dragArrowPointerId = null;

    let currentArrowColor = document.getElementById('arrowColorPicker').value;

    const statusBar = document.getElementById('status-bar');

    // z-index per nodi (HTML) e per oggetti sul canvas (frecce + connettori)
    let nodeZCounter = 10;
    let canvasZCounter = 1;

    // =========================
    // Utility ID
    // =========================
    function generateId() {
      return nextId++;
    }

    // =========================
    // Canvas resize
    // =========================
    function resizeCanvas() {
      const rect = workspace.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      redrawCanvas();
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    // =========================
    // ModalitÃ 
    // =========================
    function setMode(newMode) {
      mode = newMode;
      updateToolbarState();
      updateResizeHandles();
      statusBar.textContent = 'ModalitÃ : ' + newMode;
    }

    function updateToolbarState() {
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

      if (mode === 'connector') {
        document.getElementById('connectorModeBtn').classList.add('active');
      } else if (mode === 'arrow') {
        document.getElementById('arrowModeBtn').classList.add('active');
      } else if (mode === 'resizeNode') {
        document.getElementById('resizeModeBtn').classList.add('active');
      }
    }

    // =========================
    // Nodi
    // =========================
    function createNodeElement(type, x, y, content) {
      const nodeEl = document.createElement('div');
      nodeEl.classList.add('node');
      const id = generateId();
      nodeEl.dataset.id = id;
      nodeEl.style.left = x + 'px';
      nodeEl.style.top = y + 'px';

      if (type === 'text') {
        nodeEl.classList.add('text-node');
        const contentEl = document.createElement('div');
        contentEl.classList.add('node-content');
        contentEl.contentEditable = true;
        contentEl.textContent = content || 'Testo';
        contentEl.style.whiteSpace = 'pre-wrap'; // default a capo
        nodeEl.appendChild(contentEl);
      } else if (type === 'image') {
        nodeEl.classList.add('image-node');
        const img = document.createElement('img');
        img.src = content;
        nodeEl.appendChild(img);
      }

      nodeZCounter++;
      nodeEl.style.zIndex = nodeZCounter;

      workspace.appendChild(nodeEl);

      const nodeObj = {
        id,
        el: nodeEl,
        type,
        x,
        y,
        z: nodeZCounter
      };
      nodes.push(nodeObj);

      selectNode(nodeObj.id);
      updateResizeHandles();
      redrawCanvas();
    }

    function addTextNode() {
      const input = document.getElementById('textInput');
      const text = input.value.trim() || 'Testo';
      createNodeElement('text', 50, 50, text);
      input.value = '';
    }

    function addImageNode(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const src = e.target.result;
        createNodeElement('image', 80, 80, src);
      };
      reader.readAsDataURL(file);
    }

    // =========================
    // Selezione
    // =========================
    function clearSelection() {
      selectedNodeId = null;
      selectedConnectorId = null;
      selectedFreeArrowId = null;
      connectorStartNodeId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    function selectNode(id) {
      selectedNodeId = id;
      selectedConnectorId = null;
      selectedFreeArrowId = null;

      nodes.forEach(n => {
        if (n.id === id) n.el.classList.add('selected');
        else n.el.classList.remove('selected');
      });

      updateResizeHandles();
      redrawCanvas();
    }

    function selectConnector(id) {
      selectedConnectorId = id;
      selectedNodeId = null;
      selectedFreeArrowId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    function selectFreeArrow(id) {
      selectedFreeArrowId = id;
      selectedNodeId = null;
      selectedConnectorId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    function getNodeById(id) {
      return nodes.find(n => n.id === id);
    }

    // =========================
    // Ridimensionamento nodi
    // =========================
    function updateResizeHandles() {
      document.querySelectorAll('.resize-handle').forEach(h => h.remove());

      if (mode !== 'resizeNode' || !selectedNodeId) return;

      const node = getNodeById(selectedNodeId);
      if (!node) return;

      ['tl','tr','bl','br'].forEach(corner => {
        const handle = document.createElement('div');
        handle.classList.add('resize-handle', corner);
        handle.dataset.corner = corner;
        handle.addEventListener('pointerdown', onResizeHandleDown);
        node.el.appendChild(handle);
      });
    }

    function onResizeHandleDown(e) {
      e.stopPropagation();
      e.preventDefault();

      if (mode !== 'resizeNode') return;

      const handle = e.currentTarget;
      const corner = handle.dataset.corner;
      const node = getNodeById(selectedNodeId);
      if (!node) return;

      const rectWorkspace = workspace.getBoundingClientRect();
      const rect = node.el.getBoundingClientRect();

      resizingNode = node;
      resizeCorner = corner;
      resizeStart = {
        pointerId: e.pointerId,
        x: e.clientX - rectWorkspace.left,
        y: e.clientY - rectWorkspace.top,
        left: rect.left - rectWorkspace.left,
        top: rect.top - rectWorkspace.top,
        width: rect.width,
        height: rect.height
      };

      workspace.setPointerCapture(e.pointerId);
      workspace.addEventListener('pointermove', onResizePointerMove);
      workspace.addEventListener('pointerup', onResizePointerUp);
      workspace.addEventListener('pointercancel', onResizePointerUp);
    }

    function onResizePointerMove(e) {
      if (!resizingNode || !resizeStart || e.pointerId !== resizeStart.pointerId) return;

      const rectWorkspace = workspace.getBoundingClientRect();
      const x = e.clientX - rectWorkspace.left;
      const y = e.clientY - rectWorkspace.top;

      const dx = x - resizeStart.x;
      const dy = y - resizeStart.y;

      let newLeft = resizeStart.left;
      let newTop = resizeStart.top;
      let newWidth = resizeStart.width;
      let newHeight = resizeStart.height;

      if (resizeCorner === 'br') {
        newWidth = Math.max(40, resizeStart.width + dx);
        newHeight = Math.max(30, resizeStart.height + dy);
      } else if (resizeCorner === 'bl') {
        newWidth = Math.max(40, resizeStart.width - dx);
        newHeight = Math.max(30, resizeStart.height + dy);
        newLeft = resizeStart.left + dx;
      } else if (resizeCorner === 'tr') {
        newWidth = Math.max(40, resizeStart.width + dx);
        newHeight = Math.max(30, resizeStart.height - dy);
        newTop = resizeStart.top + dy;
      } else if (resizeCorner === 'tl') {
        newWidth = Math.max(40, resizeStart.width - dx);
        newHeight = Math.max(30, resizeStart.height - dy);
        newLeft = resizeStart.left + dx;
        newTop = resizeStart.top + dy;
      }

      resizingNode.el.style.left = newLeft + 'px';
      resizingNode.el.style.top = newTop + 'px';
      resizingNode.el.style.width = newWidth + 'px';
      resizingNode.el.style.height = newHeight + 'px';

      resizingNode.x = newLeft;
      resizingNode.y = newTop;

      redrawCanvas();
    }

    function onResizePointerUp(e) {
      if (!resizeStart || e.pointerId !== resizeStart.pointerId) return;

      workspace.releasePointerCapture(e.pointerId);
      workspace.removeEventListener('pointermove', onResizePointerMove);
      workspace.removeEventListener('pointerup', onResizePointerUp);
      workspace.removeEventListener('pointercancel', onResizePointerUp);

      resizingNode = null;
      resizeCorner = null;
      resizeStart = null;
    }

    // =========================
    // Sposta / trascina nodi
    // =========================
    function getTopmostNodeAt(x, y) {
      let best = null;
      let bestZ = -Infinity;
      nodes.forEach(n => {
        const rect = n.el.getBoundingClientRect();
        const wsRect = workspace.getBoundingClientRect();
        const left = rect.left - wsRect.left;
        const top = rect.top - wsRect.top;
        const right = left + rect.width;
        const bottom = top + rect.height;
        if (x >= left && x <= right && y >= top && y <= bottom) {
          if (n.z > bestZ) {
            bestZ = n.z;
            best = n;
          }
        }
      });
      return best;
    }

    // =========================
    // Workspace pointer events
    // =========================
    workspace.addEventListener('pointerdown', onWorkspacePointerDown);

    function onWorkspacePointerDown(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;

      // ModalitÃ  freccia libera
      if (mode === 'arrow') {
        e.preventDefault();

        // 1) prova a selezionare freccia esistente
        const hitArrow = findNearestArrow(x, y, 8);
        if (hitArrow) {
          selectFreeArrow(hitArrow.id);
          draggingFreeArrowId = hitArrow.id;
          dragArrowPointerId = e.pointerId;
          dragArrowStart = { pointerX: x, pointerY: y, cx: hitArrow.cx, cy: hitArrow.cy };
          return;
        }

        // 2) disegno freccia nuova (tap-tap)
        if (!drawingArrowStart) {
          drawingArrowStart = { x, y };
        } else {
          const dx = x - drawingArrowStart.x;
          const dy = y - drawingArrowStart.y;
          const length = Math.max(30, Math.sqrt(dx*dx + dy*dy));
          const angle = Math.atan2(dy, dx);
          const cx = (drawingArrowStart.x + x) / 2;
          const cy = (drawingArrowStart.y + y) / 2;
          canvasZCounter++;
          const arrow = {
            id: generateId(),
            cx,
            cy,
            length,
            angle,
            color: currentArrowColor,
            z: canvasZCounter
          };
          freeArrows.push(arrow);
          drawingArrowStart = null;
          selectFreeArrow(arrow.id);
          redrawCanvas();
        }
        return;
      }

      // ModalitÃ  connettore nodi
      if (mode === 'connector') {
        e.preventDefault();
        const node = getTopmostNodeAt(x, y);
        if (node) {
          handleConnectorClick(node.id);
        }
        return;
      }

      // ModalitÃ  ridimensiona: il drag Ã¨ gestito dalle maniglie, non da qui
      if (mode === 'resizeNode') {
        // niente drag qui, solo eventuale selezione di nodo
        const node = getTopmostNodeAt(x, y);
        if (node) {
          selectNode(node.id);
        } else {
          clearSelection();
        }
        return;
      }

      // ModalitÃ  normale: selezione e drag nodi, selezione frecce/connettori
      if (mode === 'normal') {
        const node = getTopmostNodeAt(x, y);

        if (node) {
          // Se Ã¨ un nodo di testo e fai doppio click sulla parte di testo: entra in modifica
          const targetContent = e.target.closest('.node-content');
          if (node.type === 'text' && targetContent && e.detail === 2) {
            // doppio click per edit
            targetContent.focus();
            return;
          }

          // altrimenti: drag del nodo
          e.preventDefault();
          selectNode(node.id);

          draggingNode = node;
          dragNodePointerId = e.pointerId;
          const rect = node.el.getBoundingClientRect();
          dragOffsetX = x - (rect.left - wsRect.left);
          dragOffsetY = y - (rect.top - wsRect.top);
          return;
        }

        // nessun nodo: prova frecce / connettori
        const hit = findNearestConnectorOrArrow(x, y, 8);
        if (hit && hit.type === 'connector') {
          selectConnector(hit.obj.id);
        } else if (hit && hit.type === 'arrow') {
          selectFreeArrow(hit.obj.id);
        } else {
          clearSelection();
        }
      }
    }

    function onWorkspacePointerMove(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;

      // Drag nodo
      if (mode === 'normal' && draggingNode && e.pointerId === dragNodePointerId) {
        e.preventDefault();
        const newX = x - dragOffsetX;
        const newY = y - dragOffsetY;
        draggingNode.x = newX;
        draggingNode.y = newY;
        draggingNode.el.style.left = newX + 'px';
        draggingNode.el.style.top = newY + 'px';
        redrawCanvas();
      }

      // Drag freccia libera
      if (mode === 'arrow' && draggingFreeArrowId && e.pointerId === dragArrowPointerId) {
        e.preventDefault();
        const arrow = freeArrows.find(a => a.id === draggingFreeArrowId);
        if (!arrow) return;

        const dx = x - dragArrowStart.pointerX;
        const dy = y - dragArrowStart.pointerY;
        arrow.cx = dragArrowStart.cx + dx;
        arrow.cy = dragArrowStart.cy + dy;
        redrawCanvas();
      }
    }

    function onWorkspacePointerUp(e) {
      if (draggingNode && e.pointerId === dragNodePointerId) {
        draggingNode = null;
        dragNodePointerId = null;
      }

      if (draggingFreeArrowId && e.pointerId === dragArrowPointerId) {
        draggingFreeArrowId = null;
        dragArrowPointerId = null;
      }
    }

    workspace.addEventListener('pointermove', onWorkspacePointerMove);
    workspace.addEventListener('pointerup', onWorkspacePointerUp);
    workspace.addEventListener('pointercancel', onWorkspacePointerUp);

    // =========================
    // Connettori tra nodi
    // =========================
    function handleConnectorClick(nodeId) {
      if (connectorStartNodeId == null) {
        connectorStartNodeId = nodeId;
        selectNode(nodeId);
      } else {
        const fromId = connectorStartNodeId;
        const toId = nodeId;
        if (fromId !== toId) {
          canvasZCounter++;
          const conn = {
            id: generateId(),
            fromId,
            toId,
            color: currentArrowColor,
            z: canvasZCounter
          };
          connectors.push(conn);
        }
        connectorStartNodeId = null;
        setMode('normal'); // one-shot
        clearSelection();
        redrawCanvas();
      }
    }

    function findNearestConnectorOrArrow(x, y, maxDist) {
      let best = null;
      let bestDist = maxDist;

      connectors.forEach(conn => {
        const n1 = getNodeById(conn.fromId);
        const n2 = getNodeById(conn.toId);
        if (!n1 || !n2) return;

        const p1 = getNodeCenter(n1);
        const p2 = getNodeCenter(n2);

        const d = pointToSegmentDistance(x, y, p1.x, p1.y, p2.x, p2.y);
        if (d < bestDist) {
          bestDist = d;
          best = { type: 'connector', obj: conn };
        }
      });

      freeArrows.forEach(a => {
        const p1x = a.cx - Math.cos(a.angle) * a.length / 2;
        const p1y = a.cy - Math.sin(a.angle) * a.length / 2;
        const p2x = a.cx + Math.cos(a.angle) * a.length / 2;
        const p2y = a.cy + Math.sin(a.angle) * a.length / 2;
        const d = pointToSegmentDistance(x, y, p1x, p1y, p2x, p2y);
        if (d < bestDist) {
          bestDist = d;
          best = { type: 'arrow', obj: a };
        }
      });

      return best;
    }

    function getNodeCenter(node) {
      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      const cx = rect.left - wsRect.left + rect.width / 2;
      const cy = rect.top - wsRect.top + rect.height / 2;
      return { x: cx, y: cy };
    }

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) {
        const ddx = px - x1;
        const ddy = py - y1;
        return Math.sqrt(ddx*ddx + ddy*ddy);
      }
      const t = ((px - x1)*dx + (py - y1)*dy) / (dx*dx + dy*dy);
      const tClamped = Math.max(0, Math.min(1, t));
      const projX = x1 + tClamped * dx;
      const projY = y1 + tClamped * dy;
      const ddx = px - projX;
      const ddy = py - projY;
      return Math.sqrt(ddx*ddx + ddy*ddy);
    }

    // =========================
    // Frecce libere
    // =========================
    function findNearestArrow(x, y, maxDist) {
      let bestArrow = null;
      let bestDist = maxDist;

      freeArrows.forEach(a => {
        const p1x = a.cx - Math.cos(a.angle) * a.length / 2;
        const p1y = a.cy - Math.sin(a.angle) * a.length / 2;
        const p2x = a.cx + Math.cos(a.angle) * a.length / 2;
        const p2y = a.cy + Math.sin(a.angle) * a.length / 2;
        const d = pointToSegmentDistance(x, y, p1x, p1y, p2x, p2y);
        if (d < bestDist) {
          bestDist = d;
          bestArrow = a;
        }
      });

      return bestArrow;
    }

    function adjustArrowLength(delta) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      arrow.length = Math.max(20, arrow.length + delta);
      redrawCanvas();
    }

    function rotateArrow(deltaDeg) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      const rad = deltaDeg * Math.PI / 180;
      arrow.angle += rad;
      redrawCanvas();
    }

    // =========================
    // Colori
    // =========================
    function applyBorderColor(color) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node) return;
      node.el.style.borderColor = color;
    }

    function applyTextColor(color) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;
      contentEl.style.color = color;
    }

    function applyArrowColor(color) {
      currentArrowColor = color;
      // aggiorno subito gli oggetti selezionati, se sono frecce / connettori
      if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (conn) conn.color = color;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (arrow) arrow.color = color;
      }
      redrawCanvas();
    }

    // =========================
    // Livelli (z-index)
    // =========================
    function bringToFront() {
      if (!selectedNodeId && !selectedConnectorId && !selectedFreeArrowId) return;

      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        nodeZCounter++;
        node.z = nodeZCounter;
        node.el.style.zIndex = nodeZCounter;
      } else if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (!conn) return;
        canvasZCounter++;
        conn.z = canvasZCounter;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (!arrow) return;
        canvasZCounter++;
        arrow.z = canvasZCounter;
      }

      redrawCanvas();
    }

    function sendToBack() {
      if (!selectedNodeId && !selectedConnectorId && !selectedFreeArrowId) return;

      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        let minZ = Infinity;
        nodes.forEach(n => { if (n.z < minZ) minZ = n.z; });
        node.z = minZ - 1;
        node.el.style.zIndex = node.z;
      } else if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (!conn) return;
        let minZ = Infinity;
        connectors.forEach(c => { if (c.z < minZ) minZ = c.z; });
        freeArrows.forEach(a => { if (a.z < minZ) minZ = a.z; });
        conn.z = minZ - 1;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (!arrow) return;
        let minZ = Infinity;
        connectors.forEach(c => { if (c.z < minZ) minZ = c.z; });
        freeArrows.forEach(a => { if (a.z < minZ) minZ = a.z; });
        arrow.z = minZ - 1;
      }

      redrawCanvas();
    }

    // =========================
    // Delete
    // =========================
    function deleteSelected() {
      if (selectedNodeId) {
        // cancella nodo + connettori collegati
        const nodeId = selectedNodeId;
        const node = getNodeById(nodeId);
        if (node) {
          node.el.remove();
        }
        nodes = nodes.filter(n => n.id !== nodeId);
        connectors = connectors.filter(c => c.fromId !== nodeId && c.toId !== nodeId);
        selectedNodeId = null;
      } else if (selectedConnectorId) {
        connectors = connectors.filter(c => c.id !== selectedConnectorId);
        selectedConnectorId = null;
      } else if (selectedFreeArrowId) {
        freeArrows = freeArrows.filter(a => a.id !== selectedFreeArrowId);
        selectedFreeArrowId = null;
      }
      clearSelection();
      redrawCanvas();
    }

    function clearAll() {
      nodes.forEach(n => n.el.remove());
      nodes = [];
      connectors = [];
      freeArrows = [];
      clearSelection();
      redrawCanvas();
    }

    // =========================
    // Disegno canvas
    // =========================
    function drawArrow(x1, y1, x2, y2, color, isSelected) {
      const headLength = 10;
      const dx = x2 - x1;
      const dy = y2 - y1;
      const angle = Math.atan2(dy, dx);

      ctx.save();
      ctx.lineWidth = isSelected ? 3 : 2;
      ctx.strokeStyle = color || '#000';
      ctx.fillStyle = color || '#000';

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6),
                 y2 - headLength * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6),
                 y2 - headLength * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function redrawCanvas() {
      const rect = workspace.getBoundingClientRect();
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Ordina oggetti per z
      const connectorsSorted = [...connectors].sort((a,b) => a.z - b.z);
      const arrowsSorted = [...freeArrows].sort((a,b) => a.z - b.z);

      // Disegna connettori
      connectorsSorted.forEach(conn => {
        const n1 = getNodeById(conn.fromId);
        const n2 = getNodeById(conn.toId);
        if (!n1 || !n2) return;
        const c1 = getNodeCenter(n1);
        const c2 = getNodeCenter(n2);
        const isSelected = (conn.id === selectedConnectorId);
        drawArrow(c1.x, c1.y, c2.x, c2.y, conn.color, isSelected);
      });

      // Disegna frecce libere
      arrowsSorted.forEach(a => {
        const x1 = a.cx - Math.cos(a.angle) * a.length / 2;
        const y1 = a.cy - Math.sin(a.angle) * a.length / 2;
        const x2 = a.cx + Math.cos(a.angle) * a.length / 2;
        const y2 = a.cy + Math.sin(a.angle) * a.length / 2;
        const isSelected = (a.id === selectedFreeArrowId);
        drawArrow(x1,y1,x2,y2, a.color, isSelected);
      });
    }

    // =========================
    // Export PNG / PDF
    // =========================
    async function saveAsPng(scale = 1, filenameSuffix = '') {
      const canvasExport = await html2canvas(workspace, { scale });
      const link = document.createElement('a');
      link.href = canvasExport.toDataURL('image/png');
      link.download = 'mindweave-lavagna' + filenameSuffix + '.png';
      link.click();
    }

    async function saveAsPdf() {
      const canvasExport = await html2canvas(workspace);
      const imgData = canvasExport.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('l', 'pt', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const ratio = Math.min(pageWidth / canvasExport.width, pageHeight / canvasExport.height);
      const imgWidth = canvasExport.width * ratio;
      const imgHeight = canvasExport.height * ratio;
      const x = (pageWidth - imgWidth) / 2;
      const y = (pageHeight - imgHeight) / 2;
      pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
      pdf.save('mindweave-lavagna.pdf');
    }

    // =========================
    // Salva / Carica stato lavagna (formato MindWeave JSON)
    // =========================

    function exportBoardState() {
      const wsRect = workspace.getBoundingClientRect();

      const state = {
        nodes: nodes.map(n => {
          const rect = n.el.getBoundingClientRect();
          const left = rect.left - wsRect.left;
          const top = rect.top - wsRect.top;
          const width = rect.width;
          const height = rect.height;

          const base = {
            id: n.id,
            type: n.type,
            x: left,
            y: top,
            z: n.z,
            width,
            height,
            borderColor: n.el.style.borderColor || '#666666'
          };

          if (n.type === 'text') {
            const contentEl = n.el.querySelector('.node-content');
            const cs = window.getComputedStyle(contentEl);
            base.text = contentEl.textContent || '';
            base.textColor = cs.color;
            base.fontSize = cs.fontSize;
            base.whiteSpace = cs.whiteSpace;
          } else if (n.type === 'image') {
            const img = n.el.querySelector('img');
            base.src = img ? img.src : '';
          }

          return base;
        }),
        connectors: connectors.map(c => ({
          id: c.id,
          fromId: c.fromId,
          toId: c.toId,
          color: c.color,
          z: c.z
        })),
        freeArrows: freeArrows.map(a => ({
          id: a.id,
          cx: a.cx,
          cy: a.cy,
          length: a.length,
          angle: a.angle,
          color: a.color,
          z: a.z
        })),
        nextId,
        nodeZCounter,
        canvasZCounter
      };

      return state;
    }

    function downloadBoardState() {
      const state = exportBoardState();
      const json = JSON.stringify(state, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mindweave-lavagna.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function loadBoardStateFromObject(state) {
      clearAll(); // svuota lavagna

      nodes = [];
      connectors = [];
      freeArrows = [];

      const wsRect = workspace.getBoundingClientRect();

      // ricostruisci nodi
      (state.nodes || []).forEach(sn => {
        const nodeEl = document.createElement('div');
        nodeEl.classList.add('node');
        if (sn.type === 'text') nodeEl.classList.add('text-node');
        if (sn.type === 'image') nodeEl.classList.add('image-node');

        nodeEl.dataset.id = sn.id;
        nodeEl.style.position = 'absolute';
        nodeEl.style.left = (sn.x || 0) + 'px';
        nodeEl.style.top = (sn.y || 0) + 'px';
        if (sn.width) nodeEl.style.width = sn.width + 'px';
        if (sn.height) nodeEl.style.height = sn.height + 'px';
        nodeEl.style.zIndex = sn.z || 10;
        if (sn.borderColor) nodeEl.style.borderColor = sn.borderColor;

        if (sn.type === 'text') {
          const contentEl = document.createElement('div');
          contentEl.classList.add('node-content');
          contentEl.contentEditable = true;
          contentEl.textContent = sn.text || '';
          contentEl.style.textAlign = 'center';
          if (sn.textColor) contentEl.style.color = sn.textColor;
          if (sn.fontSize) contentEl.style.fontSize = sn.fontSize;
          if (sn.whiteSpace) contentEl.style.whiteSpace = sn.whiteSpace;
          nodeEl.appendChild(contentEl);
        } else if (sn.type === 'image') {
          const img = document.createElement('img');
          if (sn.src) img.src = sn.src;
          img.style.display = 'block';
          img.style.maxWidth = '100%';
          img.style.height = 'auto';
          nodeEl.appendChild(img);
        }

        workspace.appendChild(nodeEl);

        nodes.push({
          id: sn.id,
          el: nodeEl,
          type: sn.type,
          x: sn.x || 0,
          y: sn.y || 0,
          z: sn.z || 10
        });
      });

      // ricostruisci connettori e frecce
      connectors = (state.connectors || []).map(c => ({
        id: c.id,
        fromId: c.fromId,
        toId: c.toId,
        color: c.color,
        z: c.z || 1
      }));

      freeArrows = (state.freeArrows || []).map(a => ({
        id: a.id,
        cx: a.cx,
        cy: a.cy,
        length: a.length,
        angle: a.angle,
        color: a.color,
        z: a.z || 1
      }));

      // aggiorna contatori ID / z-index
      let maxId = 0;
      nodes.forEach(n => { if (n.id > maxId) maxId = n.id; });
      connectors.forEach(c => { if (c.id > maxId) maxId = c.id; });
      freeArrows.forEach(a => { if (a.id > maxId) maxId = a.id; });

      nextId = state.nextId || (maxId + 1);

      let maxNodeZ = 10;
      nodes.forEach(n => { if (n.z > maxNodeZ) maxNodeZ = n.z; });
      nodeZCounter = state.nodeZCounter || maxNodeZ;

      let maxCanvasZ = 1;
      connectors.forEach(c => { if (c.z > maxCanvasZ) maxCanvasZ = c.z; });
      freeArrows.forEach(a => { if (a.z > maxCanvasZ) maxCanvasZ = a.z; });
      canvasZCounter = state.canvasZCounter || maxCanvasZ;

      clearSelection();
      redrawCanvas();
    }

    function loadBoardFromFile(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const state = JSON.parse(e.target.result);
          loadBoardStateFromObject(state);
        } catch (err) {
          alert('File non valido (JSON corrotto o formato sconosciuto).');
          console.error(err);
        }
      };
      reader.readAsText(file, 'utf-8');
    }

    // =========================
    // Testo a capo ON/OFF
    // =========================
    function toggleWrapSelectedText() {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;
      const current = contentEl.style.whiteSpace || window.getComputedStyle(contentEl).whiteSpace;
      if (current === 'nowrap') {
        contentEl.style.whiteSpace = 'pre-wrap';
      } else {
        contentEl.style.whiteSpace = 'nowrap';
      }
    }

    // =========================
    // Frecce: allunga / accorcia / ruota
    // =========================
    function adjustArrowLength(delta) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      arrow.length = Math.max(20, arrow.length + delta);
      redrawCanvas();
    }

    function rotateArrow(deltaDeg) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      const rad = deltaDeg * Math.PI / 180;
      arrow.angle += rad;
      redrawCanvas();
    }

    // =========================
    // Toolbar
    // =========================
    document.getElementById('addTextBtn').addEventListener('click', addTextNode);
    document.getElementById('toggleWrapBtn').addEventListener('click', toggleWrapSelectedText);

    document.getElementById('addImageBtn').addEventListener('click', () => {
      const fileInput = document.getElementById('imageInput');
      const file = fileInput.files[0];
      addImageNode(file);
      fileInput.value = '';
    });

    document.getElementById('resizeModeBtn').addEventListener('click', () => {
      if (mode === 'resizeNode') setMode('normal');
      else setMode('resizeNode');
    });

    document.getElementById('nodePlusBtn').addEventListener('click', () => {
      scaleSelectedNode(1.1);
    });

    document.getElementById('nodeMinusBtn').addEventListener('click', () => {
      scaleSelectedNode(0.9);
    });

    document.getElementById('connectorModeBtn').addEventListener('click', () => {
      if (mode === 'connector') setMode('normal');
      else {
        clearSelection();
        setMode('connector');
      }
    });

    document.getElementById('arrowModeBtn').addEventListener('click', () => {
      if (mode === 'arrow') {
        setMode('normal');
        drawingArrowStart = null;
      } else {
        clearSelection();
        drawingArrowStart = null;
        setMode('arrow');
      }
    });

    document.getElementById('arrowLengthPlusBtn').addEventListener('click', () => {
      adjustArrowLength(10);
    });

    document.getElementById('arrowLengthMinusBtn').addEventListener('click', () => {
      adjustArrowLength(-10);
    });

    document.getElementById('arrowRotateLeftBtn').addEventListener('click', () => {
      rotateArrow(-5);
    });

    document.getElementById('arrowRotateRightBtn').addEventListener('click', () => {
      rotateArrow(5);
    });

    document.getElementById('borderColorPicker').addEventListener('input', (e) => {
      applyBorderColor(e.target.value);
    });

    document.getElementById('textColorPicker').addEventListener('input', (e) => {
      applyTextColor(e.target.value);
    });

    document.getElementById('arrowColorPicker').addEventListener('input', (e) => {
      applyArrowColor(e.target.value);
    });

    document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);
    document.getElementById('clearAllBtn').addEventListener('click', clearAll);

    // PNG standard
    document.getElementById('savePngStandardBtn').addEventListener('click', () => {
      saveAsPng(1, '');
    });

    // PNG alta qualitÃ  per LIM
    document.getElementById('savePngHQBtn').addEventListener('click', () => {
      saveAsPng(4, '-HQ');
    });

    document.getElementById('savePdfBtn').addEventListener('click', saveAsPdf);

    // Salva / Apri lavagna (formato MindWeave JSON)
    document.getElementById('saveBoardBtn').addEventListener('click', () => {
      downloadBoardState();
    });

    document.getElementById('loadBoardBtn').addEventListener('click', () => {
      const input = document.getElementById('loadBoardInput');
      input.value = '';
      input.click();
    });

    document.getElementById('loadBoardInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      loadBoardFromFile(file);
    });

    document.getElementById('bringToFrontBtn').addEventListener('click', bringToFront);
    document.getElementById('sendToBackBtn').addEventListener('click', sendToBack);

    // =========================
    // Scala nodo selezionato
    // =========================
    function scaleSelectedNode(factor) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node) return;

      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      const left = rect.left - wsRect.left;
      const top = rect.top - wsRect.top;
      const newWidth = Math.max(40, rect.width * factor);
      const newHeight = Math.max(30, rect.height * factor);

      node.el.style.width = newWidth + 'px';
      node.el.style.height = newHeight + 'px';

      node.x = left;
      node.y = top;

      redrawCanvas();
    }

    // Init
    setMode('normal');
  </script>
</body>
</html>
