<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>MindWeave â€“ Lavagna concettuale (Fixed)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f0f0f0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #222;
      color: #fff;
      padding: 6px 10px;
      font-size: 14px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
      z-index: 20000; /* Header sempre sopra tutto */
    }

    header .group-label {
      font-weight: 600;
      margin-right: 4px;
      color: #ccc;
    }

    button.tool-btn {
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #333;
      color: #fff;
      cursor: pointer;
    }

    button.tool-btn:hover {
      background: #444;
    }

    button.tool-btn.active {
      background: #ff9800;
      border-color: #ff9800;
      color: #000;
    }

    input[type="color"] {
      padding: 0;
      border: 1px solid #555;
      border-radius: 4px;
      width: 30px;
      height: 24px;
      background: transparent;
      cursor: pointer;
    }

    input[type="text"],
    input[type="file"] {
      font-size: 12px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #999;
      background: #fff;
      color: #000;
    }

    #workspace-wrapper {
      flex: 1;
      padding: 6px;
      display: flex;
      position: relative;
      overflow: hidden;
    }

    #workspace {
      position: relative;
      flex: 1;
      background: #ffffff;
      border-radius: 6px;
      border: 1px solid #ccc;
      overflow: hidden;
      touch-action: none;
    }

    /* FIX LAYER: Il canvas ora Ã¨ SOPRA i nodi (z-index alto), 
       ma lascia passare i click (pointer-events: none) 
       a meno che il mouse non sia su una freccia (gestito via JS).
    */
    #connectorCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 10000; 
      pointer-events: none; 
    }

    .node {
      position: absolute;
      min-width: 80px;
      min-height: 40px;
      padding: 6px;
      border-radius: 6px;
      border: 2px solid #666;
      background: #fff;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
      touch-action: none;
      /* Cursore di default per spostare */
      cursor: grab;
    }

    .node:active {
      cursor: grabbing;
    }

    .node.selected {
      border-color: red;
      box-shadow: 0 0 0 2px rgba(255, 0, 0, 0.3);
    }

    .node.text-node {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .node.text-node .node-content {
      width: 100%;
      min-height: 20px;
      outline: none;
      font-size: 14px;
      white-space: pre-wrap;
      word-wrap: break-word;
      text-align: center;
      /* Importante: il testo non seleziona nativamente finchÃ© non si edita */
      pointer-events: none; 
    }

    /* Quando siamo in modalitÃ  edit (contenteditable=true) */
    .node.text-node.editing .node-content {
      pointer-events: auto;
      cursor: text;
      -webkit-user-select: text;
      user-select: text;
      background: rgba(255, 255, 0, 0.1); /* Leggero feedback visivo */
    }
    
    .node.text-node.editing {
      cursor: text;
      border-style: dashed;
    }

    .node.image-node img {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: fill; /* Adatta l'immagine al resize */
      pointer-events: none;
    }

    /* Maniglie di ridimensionamento */
    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: #ff9800;
      border: 1px solid #333;
      z-index: 10001; /* Sopra al canvas */
      cursor: pointer;
    }
    .resize-handle.tl { top: -6px; left: -6px; cursor: nwse-resize; }
    .resize-handle.tr { top: -6px; right: -6px; cursor: nesw-resize; }
    .resize-handle.bl { bottom: -6px; left: -6px; cursor: nesw-resize; }
    .resize-handle.br { bottom: -6px; right: -6px; cursor: nwse-resize; }

    #status-bar {
      font-size: 12px;
      padding: 4px 8px;
      background: #eee;
      border-top: 1px solid #ccc;
      color: #333;
    }
  </style>
</head>
<body>
  <header>
    <span class="group-label">Testo:</span>
    <input type="text" id="textInput" placeholder="Nuovo testo..." />
    <button class="tool-btn" id="addTextBtn">ðŸ…£ Aggiungi</button>
    
    <span class="group-label">Immagine:</span>
    <input type="file" id="imageInput" accept="image/*" />
    <button class="tool-btn" id="addImageBtn">ðŸ–¼ Aggiungi</button>

    <span class="group-label">Nodo:</span>
    <button class="tool-btn" id="resizeModeBtn" title="Ridimensiona manualmente">ðŸ”³ Resize</button>
    <button class="tool-btn" id="nodePlusBtn" title="Ingrandisci">+10%</button>
    <button class="tool-btn" id="nodeMinusBtn" title="Rimpicciolisci">-10%</button>
    <button class="tool-btn" id="bringToFrontBtn" title="Porta in primo piano">â¬† Primo</button>
    <button class="tool-btn" id="sendToBackBtn" title="Manda dietro">â¬‡ Dietro</button>

    <span class="group-label">Connessioni:</span>
    <button class="tool-btn" id="connectorModeBtn" title="Collega due nodi">â–¡â†’â–¡ Link</button>
    <button class="tool-btn" id="arrowModeBtn" title="Disegna freccia libera">âžœ Freccia</button>

    <span class="group-label">Modifica Freccia:</span>
    <button class="tool-btn" id="arrowLengthPlusBtn">â†”+</button>
    <button class="tool-btn" id="arrowLengthMinusBtn">â†”âˆ’</button>
    <button class="tool-btn" id="arrowRotateLeftBtn">ðŸ”„sx</button>
    <button class="tool-btn" id="arrowRotateRightBtn">ðŸ”„dx</button>

    <span class="group-label">Stile:</span>
    <label title="Bordo Nodo">ðŸ–¼</label><input type="color" id="borderColorPicker" value="#666666" />
    <label title="Testo">A</label><input type="color" id="textColorPicker" value="#000000" />
    <label title="Freccia">âžœ</label><input type="color" id="arrowColorPicker" value="#0000ff" />

    <span class="group-label">Gestione:</span>
    <button class="tool-btn" id="deleteSelectedBtn" style="background:#500;">ðŸ—‘ Elimina</button>
    <button class="tool-btn" id="clearAllBtn">ðŸ§¹ Pulisci</button>
    <button class="tool-btn" id="savePngBtn">ðŸ“¸ PNG</button>
    <button class="tool-btn" id="savePdfBtn">ðŸ“„ PDF</button>
  </header>

  <div id="workspace-wrapper">
    <div id="workspace">
      <canvas id="connectorCanvas"></canvas>
      </div>
  </div>

  <div id="status-bar">ModalitÃ : Normale (Doppio click sul testo per modificare)</div>

  <script>
    // =========================
    // Configurazione e Stato
    // =========================
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('connectorCanvas');
    const ctx = canvas.getContext('2d');
    const statusBar = document.getElementById('status-bar');

    let mode = 'normal'; // 'normal', 'connector', 'arrow', 'resizeNode'
    
    // Liste dati
    let nodes = [];       // {id, el, type, x, y, z}
    let connectors = [];  // {id, fromId, toId, color, z}
    let freeArrows = [];  // {id, cx, cy, length, angle, color, z}
    
    let nextId = 1;
    let nodeZCounter = 10; // Z-index per i div dei nodi

    // Selezione
    let selectedNodeId = null;
    let selectedConnectorId = null;
    let selectedFreeArrowId = null;

    // Dragging / Interazione
    let draggingNode = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    let connectorStartNodeId = null; // Primo nodo per collegamento
    
    // Resize nodo manuale
    let resizingNode = null;
    let resizeCorner = null;
    let resizeStart = null;

    // Disegno/Drag Frecce
    let drawingArrowStart = null;
    let draggingFreeArrowId = null;
    let dragArrowStart = null;

    let currentArrowColor = document.getElementById('arrowColorPicker').value;

    // =========================
    // Inizializzazione Canvas
    // =========================
    function generateId() { return nextId++; }

    function resizeCanvas() {
      const rect = workspace.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      redrawCanvas();
    }
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    // =========================
    // Creazione Nodi
    // =========================
    function createNodeElement(type, x, y, content) {
      const nodeEl = document.createElement('div');
      nodeEl.classList.add('node');
      const id = generateId();
      nodeEl.dataset.id = id;
      
      // Posizione
      nodeEl.style.left = x + 'px';
      nodeEl.style.top = y + 'px';
      
      // Z-Index incrementale (sempre sopra al precedente)
      nodeZCounter++;
      nodeEl.style.zIndex = nodeZCounter;

      if (type === 'text') {
        nodeEl.classList.add('text-node');
        const contentEl = document.createElement('div');
        contentEl.classList.add('node-content');
        contentEl.innerText = content || 'Testo';
        
        // FIX: Inizialmente NON editabile per permettere il drag
        contentEl.contentEditable = "false"; 

        nodeEl.appendChild(contentEl);

        // Gestione Doppio Click per editare testo
        nodeEl.addEventListener('dblclick', (e) => {
          if (mode !== 'normal') return;
          e.stopPropagation(); // Evita conflitti
          
          contentEl.contentEditable = "true";
          nodeEl.classList.add('editing');
          contentEl.focus();
          
          // Seleziona tutto il testo per comoditÃ 
          const range = document.createRange();
          range.selectNodeContents(contentEl);
          const sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        });

        // Quando perde il focus, torna non editabile
        contentEl.addEventListener('blur', () => {
          contentEl.contentEditable = "false";
          nodeEl.classList.remove('editing');
          window.getSelection().removeAllRanges();
        });

      } else if (type === 'image') {
        nodeEl.classList.add('image-node');
        const img = document.createElement('img');
        img.src = content;
        img.onload = () => redrawCanvas(); // Ridisegna se serve
        nodeEl.appendChild(img);
        
        // Dimensioni di default per immagini grandi
        nodeEl.style.width = "200px";
        nodeEl.style.height = "auto";
      }

      // Listener per il Drag/Selezione
      nodeEl.addEventListener('pointerdown', onNodePointerDown);

      workspace.appendChild(nodeEl);

      const nodeObj = { id, el: nodeEl, type, x, y, z: nodeZCounter };
      nodes.push(nodeObj);

      selectNode(id);
      redrawCanvas();
    }

    function addTextNode() {
      const input = document.getElementById('textInput');
      const text = input.value.trim() || 'Doppio click qui';
      // Posiziona al centro o random
      createNodeElement('text', 100, 100, text);
      input.value = '';
    }

    function addImageNode(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (e) => {
        createNodeElement('image', 150, 150, e.target.result);
      };
      reader.readAsDataURL(file);
    }

    // =========================
    // Selezione Unica
    // =========================
    function clearSelection() {
      selectedNodeId = null;
      selectedConnectorId = null;
      selectedFreeArrowId = null;
      connectorStartNodeId = null;

      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    function selectNode(id) {
      clearSelection(); // Deseleziona frecce/altri nodi
      selectedNodeId = id;
      const node = getNodeById(id);
      if (node) node.el.classList.add('selected');
      updateResizeHandles();
      redrawCanvas();
    }

    function selectConnector(id) {
      clearSelection();
      selectedConnectorId = id;
      redrawCanvas();
    }

    function selectFreeArrow(id) {
      clearSelection();
      selectedFreeArrowId = id;
      redrawCanvas();
    }

    // =========================
    // Gestione Eventi Nodi (Drag & Drop)
    // =========================
    function onNodePointerDown(e) {
      const nodeEl = e.currentTarget;
      const id = Number(nodeEl.dataset.id);

      // Se stiamo editando il testo, non interferire col click
      if (nodeEl.classList.contains('editing')) {
        return; 
      }

      e.preventDefault(); 
      e.stopPropagation(); // Ferma l'evento qui, non va al workspace

      // ModalitÃ  Connettore
      if (mode === 'connector') {
        handleConnectorClick(id);
        return;
      }
      // ModalitÃ  Resize
      if (mode === 'resizeNode') {
        selectNode(id);
        return;
      }

      // ModalitÃ  Normale: Seleziona e Prepara Drag
      selectNode(id);
      draggingNode = getNodeById(id);
      
      const rect = nodeEl.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      
      dragOffsetX = e.clientX - rect.left;
      dragOffsetY = e.clientY - rect.top;

      nodeEl.setPointerCapture(e.pointerId);
      nodeEl.addEventListener('pointermove', onNodePointerMove);
      nodeEl.addEventListener('pointerup', onNodePointerUp);
      nodeEl.addEventListener('pointercancel', onNodePointerUp);
    }

    function onNodePointerMove(e) {
      if (!draggingNode) return;
      e.preventDefault();
      
      const wsRect = workspace.getBoundingClientRect();
      let newX = e.clientX - wsRect.left - dragOffsetX;
      let newY = e.clientY - wsRect.top - dragOffsetY;

      draggingNode.x = newX;
      draggingNode.y = newY;
      draggingNode.el.style.left = newX + 'px';
      draggingNode.el.style.top = newY + 'px';

      // Ridisegna frecce collegate mentre sposti
      redrawCanvas();
    }

    function onNodePointerUp(e) {
      const nodeEl = e.currentTarget;
      nodeEl.removeEventListener('pointermove', onNodePointerMove);
      nodeEl.removeEventListener('pointerup', onNodePointerUp);
      nodeEl.removeEventListener('pointercancel', onNodePointerUp);
      draggingNode = null;
    }

    function getNodeById(id) { return nodes.find(n => n.id === id); }

    // =========================
    // Gestione Eventi Workspace (Frecce & Click Vuoto)
    // =========================
    
    // SMART HOVER: Rende il canvas cliccabile solo se sopra una freccia
    workspace.addEventListener('pointermove', (e) => {
      if (draggingNode || resizingNode || draggingFreeArrowId) return; // Se stiamo trascinando, ignora

      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;

      // Cerca se c'Ã¨ qualcosa sotto il mouse sul canvas
      const hit = findNearestConnectorOrArrow(x, y, 10);
      
      if (hit) {
        // C'Ã¨ una freccia sotto il mouse: attiva il canvas per ricevere il click
        canvas.style.pointerEvents = 'auto';
        canvas.style.cursor = 'pointer';
      } else {
        // Nessuna freccia: lascia passare il click agli elementi sotto (es. immagini)
        canvas.style.pointerEvents = 'none';
        canvas.style.cursor = 'default';
        
        // Se siamo in modalitÃ  creazione freccia, il canvas deve prendere i click
        if (mode === 'arrow') {
           canvas.style.pointerEvents = 'auto';
           canvas.style.cursor = 'crosshair';
        }
      }
    });

    canvas.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;

      // 1. Gestione Creazione/Selezione Frecce Libere
      if (mode === 'arrow') {
        const hitArrow = findNearestArrow(x, y, 10);
        if (hitArrow) {
          // Se clicco su una esistente, la sposto
          selectFreeArrow(hitArrow.id);
          draggingFreeArrowId = hitArrow.id;
          dragArrowStart = { pointerX: x, pointerY: y, cx: hitArrow.cx, cy: hitArrow.cy };
          canvas.setPointerCapture(e.pointerId);
          canvas.addEventListener('pointermove', onArrowDragMove);
          canvas.addEventListener('pointerup', onArrowDragUp);
          return;
        }

        // Creazione nuova freccia (tap-tap logic)
        if (!drawingArrowStart) {
          drawingArrowStart = { x, y };
        } else {
          const dx = x - drawingArrowStart.x;
          const dy = y - drawingArrowStart.y;
          const length = Math.max(30, Math.sqrt(dx*dx + dy*dy));
          const angle = Math.atan2(dy, dx);
          const cx = (drawingArrowStart.x + x) / 2;
          const cy = (drawingArrowStart.y + y) / 2;
          
          const arrow = {
            id: generateId(),
            cx, cy, length, angle,
            color: currentArrowColor
          };
          freeArrows.push(arrow);
          drawingArrowStart = null;
          selectFreeArrow(arrow.id);
          redrawCanvas();
        }
      } 
      // 2. ModalitÃ  Normale: Selezione Connettori/Frecce
      else if (mode === 'normal') {
        const hit = findNearestConnectorOrArrow(x, y, 10);
        if (hit && hit.type === 'connector') {
          selectConnector(hit.obj.id);
        } else if (hit && hit.type === 'arrow') {
          selectFreeArrow(hit.obj.id);
          // Permetti drag immediato anche qui
          draggingFreeArrowId = hit.obj.id;
          dragArrowStart = { pointerX: x, pointerY: y, cx: hit.obj.cx, cy: hit.obj.cy };
          canvas.setPointerCapture(e.pointerId);
          canvas.addEventListener('pointermove', onArrowDragMove);
          canvas.addEventListener('pointerup', onArrowDragUp);
        } else {
          clearSelection();
        }
      }
    });

    // Drag Frecce
    function onArrowDragMove(e) {
      if (!draggingFreeArrowId) return;
      e.preventDefault();
      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;
      
      const arrow = freeArrows.find(a => a.id === draggingFreeArrowId);
      if (!arrow) return;

      const dx = x - dragArrowStart.pointerX;
      const dy = y - dragArrowStart.pointerY;
      arrow.cx = dragArrowStart.cx + dx;
      arrow.cy = dragArrowStart.cy + dy;
      redrawCanvas();
    }

    function onArrowDragUp(e) {
      canvas.removeEventListener('pointermove', onArrowDragMove);
      canvas.removeEventListener('pointerup', onArrowDragUp);
      draggingFreeArrowId = null;
    }

    // Click vuoto sul wrapper per deselezionare tutto
    workspace.addEventListener('pointerdown', (e) => {
      // Se ho cliccato proprio il div workspace (sfondo) e non un nodo o il canvas
      if (e.target === workspace && mode === 'normal') {
        clearSelection();
      }
    });

    // =========================
    // Geometria e Calcoli
    // =========================
    function distancePointToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) return Math.hypot(px - x1, py - y1);
      const t = ((px - x1) * dx + (py - y1) * dy) / (dx*dx + dy*dy);
      const clamped = Math.max(0, Math.min(1, t));
      const projX = x1 + clamped * dx;
      const projY = y1 + clamped * dy;
      return Math.hypot(px - projX, py - projY);
    }

    function getArrowEndpoints(arrow) {
      const half = arrow.length / 2;
      const dx = Math.cos(arrow.angle) * half;
      const dy = Math.sin(arrow.angle) * half;
      return { x1: arrow.cx - dx, y1: arrow.cy - dy, x2: arrow.cx + dx, y2: arrow.cy + dy };
    }

    function findNearestArrow(x, y, threshold) {
      let best = null;
      let bestDist = Infinity;
      freeArrows.forEach(a => {
        const {x1,y1,x2,y2} = getArrowEndpoints(a);
        const d = distancePointToSegment(x,y,x1,y1,x2,y2);
        if (d < threshold && d < bestDist) {
          bestDist = d;
          best = a;
        }
      });
      return best;
    }

    function findNearestConnectorOrArrow(x, y, threshold) {
      let best = null;
      let bestDist = Infinity;

      // Connettori
      connectors.forEach(c => {
        const fromNode = getNodeById(c.fromId);
        const toNode = getNodeById(c.toId);
        if (!fromNode || !toNode) return;
        const p1 = getNodeCenter(fromNode);
        const p2 = getNodeCenter(toNode);
        const d = distancePointToSegment(x,y,p1.x,p1.y,p2.x,p2.y);
        if (d < threshold && d < bestDist) {
          bestDist = d;
          best = {type: 'connector', obj: c};
        }
      });

      // Frecce libere
      freeArrows.forEach(a => {
        const {x1,y1,x2,y2} = getArrowEndpoints(a);
        const d = distancePointToSegment(x,y,x1,y1,x2,y2);
        if (d < threshold && d < bestDist) {
          bestDist = d;
          best = {type: 'arrow', obj: a};
        }
      });
      return best;
    }

    function getNodeCenter(node) {
      // Usiamo le coordinate salvate o il DOM
      // (Meglio DOM live per size corretto)
      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      return {
        x: (rect.left - wsRect.left) + rect.width / 2,
        y: (rect.top - wsRect.top) + rect.height / 2
      };
    }

    function handleConnectorClick(nodeId) {
      if (connectorStartNodeId == null) {
        connectorStartNodeId = nodeId;
        selectNode(nodeId);
      } else {
        const fromId = connectorStartNodeId;
        const toId = nodeId;
        if (fromId !== toId) {
          connectors.push({
            id: generateId(),
            fromId, toId,
            color: currentArrowColor
          });
        }
        connectorStartNodeId = null;
        setMode('normal');
      }
      redrawCanvas();
    }

    // =========================
    // Resize Manuale Nodi
    // =========================
    function updateResizeHandles() {
      document.querySelectorAll('.resize-handle').forEach(h => h.remove());
      if (mode !== 'resizeNode' || !selectedNodeId) return;

      const node = getNodeById(selectedNodeId);
      if (!node) return;

      ['tl','tr','bl','br'].forEach(corner => {
        const handle = document.createElement('div');
        handle.classList.add('resize-handle', corner);
        handle.dataset.corner = corner;
        handle.addEventListener('pointerdown', onResizeHandleDown);
        node.el.appendChild(handle);
      });
    }

    function onResizeHandleDown(e) {
      e.preventDefault(); e.stopPropagation();
      const handle = e.currentTarget;
      const corner = handle.dataset.corner;
      const node = getNodeById(selectedNodeId);
      
      resizingNode = node;
      resizeCorner = corner;

      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      
      resizeStart = {
        pointerX: e.clientX - wsRect.left,
        pointerY: e.clientY - wsRect.top,
        left: rect.left - wsRect.left,
        top: rect.top - wsRect.top,
        width: rect.width,
        height: rect.height,
        aspect: rect.height / rect.width
      };

      handle.setPointerCapture(e.pointerId);
      handle.addEventListener('pointermove', onResizeHandleMove);
      handle.addEventListener('pointerup', onResizeHandleUp);
    }

    function onResizeHandleMove(e) {
      if (!resizingNode || !resizeStart) return;
      e.preventDefault();
      const wsRect = workspace.getBoundingClientRect();
      const px = e.clientX - wsRect.left;
      const py = e.clientY - wsRect.top;
      
      let dx = px - resizeStart.pointerX;
      let dy = py - resizeStart.pointerY;

      let newLeft = resizeStart.left;
      let newTop = resizeStart.top;
      let newW = resizeStart.width;
      let newH = resizeStart.height;

      if (resizeCorner.includes('r')) newW += dx;
      else { newW -= dx; newLeft += dx; }
      
      if (resizeCorner.includes('b')) newH += dy;
      else { newH -= dy; newTop += dy; }

      newW = Math.max(20, newW);
      newH = Math.max(20, newH);

      if (resizingNode.type === 'image') {
        newH = newW * resizeStart.aspect; // Maintain aspect ratio
      }

      resizingNode.el.style.width = newW + 'px';
      resizingNode.el.style.height = newH + 'px';
      resizingNode.el.style.left = newLeft + 'px';
      resizingNode.el.style.top = newTop + 'px';
      resizingNode.x = newLeft;
      resizingNode.y = newTop;
      
      redrawCanvas();
    }

    function onResizeHandleUp(e) {
      const h = e.currentTarget;
      h.removeEventListener('pointermove', onResizeHandleMove);
      h.removeEventListener('pointerup', onResizeHandleUp);
      resizingNode = null;
    }

    // =========================
    // Azioni Toolbar
    // =========================
    function setMode(newMode) {
      mode = newMode;
      
      // Toggle classi bottoni
      const btns = ['connectorModeBtn', 'arrowModeBtn', 'resizeModeBtn'];
      btns.forEach(b => document.getElementById(b).classList.remove('active'));

      if (mode === 'connector') document.getElementById('connectorModeBtn').classList.add('active');
      if (mode === 'arrow') document.getElementById('arrowModeBtn').classList.add('active');
      if (mode === 'resizeNode') document.getElementById('resizeModeBtn').classList.add('active');

      // Update testo status bar
      const labels = {
        'normal': 'ModalitÃ : Normale (Doppio click sul testo per modificare)',
        'connector': 'ModalitÃ : Clicca sul nodo A poi sul nodo B',
        'arrow': 'ModalitÃ : Clicca due punti per creare freccia (o trascina esistente)',
        'resizeNode': 'ModalitÃ : Trascina gli angoli arancioni'
      };
      statusBar.textContent = labels[mode] || mode;

      updateResizeHandles();
      
      // Reset puntatori canvas
      if (mode === 'arrow') {
        canvas.style.pointerEvents = 'auto';
        canvas.style.cursor = 'crosshair';
      } else {
        canvas.style.pointerEvents = 'none';
        canvas.style.cursor = 'default';
      }
    }

    // Scala nodi
    function scaleSelectedNode(factor) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      const rect = node.el.getBoundingClientRect();
      
      const newW = Math.max(30, rect.width * factor);
      const newH = Math.max(20, rect.height * factor);
      
      node.el.style.width = newW + 'px';
      node.el.style.height = newH + 'px';

      // Scala font per testo
      if (node.type === 'text') {
        const contentEl = node.el.querySelector('.node-content');
        const cs = window.getComputedStyle(contentEl);
        const currSize = parseFloat(cs.fontSize) || 14;
        contentEl.style.fontSize = (currSize * factor) + 'px';
      }
      redrawCanvas();
    }

    // Z-Index Layers
    function bringToFront() {
      if (selectedNodeId) {
        nodeZCounter++;
        const node = getNodeById(selectedNodeId);
        node.z = nodeZCounter;
        node.el.style.zIndex = nodeZCounter;
      }
      redrawCanvas();
    }

    function sendToBack() {
      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        // Per mandare davvero dietro, deve essere minore degli altri
        // Semplificazione: mettiamo a 1. Se c'Ã¨ altro a 1, pazienza.
        node.z = 1; 
        node.el.style.zIndex = 1;
      }
      redrawCanvas();
    }

    function deleteSelected() {
      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        node.el.remove();
        nodes = nodes.filter(n => n.id !== selectedNodeId);
        connectors = connectors.filter(c => c.fromId !== selectedNodeId && c.toId !== selectedNodeId);
      } else if (selectedConnectorId) {
        connectors = connectors.filter(c => c.id !== selectedConnectorId);
      } else if (selectedFreeArrowId) {
        freeArrows = freeArrows.filter(a => a.id !== selectedFreeArrowId);
      }
      clearSelection();
      redrawCanvas();
    }

    function clearAll() {
      nodes.forEach(n => n.el.remove());
      nodes = []; connectors = []; freeArrows = [];
      nodeZCounter = 10;
      nextId = 1;
      clearSelection();
      redrawCanvas();
    }

    // Rotazione Frecce
    function rotateArrow(deg) {
      if (!selectedFreeArrowId) return;
      const a = freeArrows.find(x => x.id === selectedFreeArrowId);
      if (a) {
        a.angle += deg * Math.PI / 180;
        redrawCanvas();
      }
    }
    function adjustArrowLength(delta) {
      if (!selectedFreeArrowId) return;
      const a = freeArrows.find(x => x.id === selectedFreeArrowId);
      if (a) {
        a.length = Math.max(20, a.length + delta);
        redrawCanvas();
      }
    }

    // =========================
    // Disegno Canvas
    // =========================
    function drawArrowHead(ctx, x, y, angle, color) {
      const headLen = 10;
      ctx.beginPath();
      ctx.moveTo(x, y);
      ctx.lineTo(x - headLen * Math.cos(angle - Math.PI/6), y - headLen * Math.sin(angle - Math.PI/6));
      ctx.lineTo(x - headLen * Math.cos(angle + Math.PI/6), y - headLen * Math.sin(angle + Math.PI/6));
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
    }

    function drawLineArrow(x1, y1, x2, y2, color, isSelected) {
      ctx.strokeStyle = isSelected ? 'red' : color;
      ctx.lineWidth = isSelected ? 3 : 2;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      const angle = Math.atan2(y2 - y1, x2 - x1);
      drawArrowHead(ctx, x2, y2, angle, isSelected ? 'red' : color);
    }

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Disegna connettori
      connectors.forEach(c => {
        const from = getNodeById(c.fromId);
        const to = getNodeById(c.toId);
        if (from && to) {
          const p1 = getNodeCenter(from);
          const p2 = getNodeCenter(to);
          drawLineArrow(p1.x, p1.y, p2.x, p2.y, c.color, c.id === selectedConnectorId);
        }
      });

      // Disegna frecce libere
      freeArrows.forEach(a => {
        const pts = getArrowEndpoints(a);
        drawLineArrow(pts.x1, pts.y1, pts.x2, pts.y2, a.color, a.id === selectedFreeArrowId);
      });
    }

    // =========================
    // Export
    // =========================
    async function saveAsPng() {
      clearSelection(); // Rimuovi bordi rossi prima di salvare
      const canvasExport = await html2canvas(workspace, { scale: 2 });
      const link = document.createElement('a');
      link.href = canvasExport.toDataURL('image/png');
      link.download = 'mindweave.png';
      link.click();
    }

    async function saveAsPdf() {
      clearSelection();
      const canvasExport = await html2canvas(workspace, { scale: 2 });
      const imgData = canvasExport.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('l', 'pt', 'a4');
      const pW = pdf.internal.pageSize.getWidth();
      const pH = pdf.internal.pageSize.getHeight();
      const ratio = Math.min(pW / canvasExport.width, pH / canvasExport.height);
      const w = canvasExport.width * ratio;
      const h = canvasExport.height * ratio;
      pdf.addImage(imgData, 'PNG', (pW-w)/2, (pH-h)/2, w, h);
      pdf.save('mindweave.pdf');
    }

    // =========================
    // Binding Eventi DOM
    // =========================
    document.getElementById('addTextBtn').addEventListener('click', addTextNode);
    document.getElementById('addImageBtn').addEventListener('click', () => document.getElementById('imageInput').click());
    document.getElementById('imageInput').addEventListener('change', (e) => addImageNode(e.target.files[0]));
    
    document.getElementById('nodePlusBtn').addEventListener('click', () => scaleSelectedNode(1.1));
    document.getElementById('nodeMinusBtn').addEventListener('click', () => scaleSelectedNode(0.9));
    
    document.getElementById('bringToFrontBtn').addEventListener('click', bringToFront);
    document.getElementById('sendToBackBtn').addEventListener('click', sendToBack);
    
    document.getElementById('resizeModeBtn').addEventListener('click', () => setMode(mode === 'resizeNode' ? 'normal' : 'resizeNode'));
    document.getElementById('connectorModeBtn').addEventListener('click', () => setMode(mode === 'connector' ? 'normal' : 'connector'));
    document.getElementById('arrowModeBtn').addEventListener('click', () => setMode(mode === 'arrow' ? 'normal' : 'arrow'));

    document.getElementById('arrowLengthPlusBtn').addEventListener('click', () => adjustArrowLength(10));
    document.getElementById('arrowLengthMinusBtn').addEventListener('click', () => adjustArrowLength(-10));
    document.getElementById('arrowRotateLeftBtn').addEventListener('click', () => rotateArrow(-10));
    document.getElementById('arrowRotateRightBtn').addEventListener('click', () => rotateArrow(10));

    document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);
    document.getElementById('clearAllBtn').addEventListener('click', clearAll);
    document.getElementById('savePngBtn').addEventListener('click', saveAsPng);
    document.getElementById('savePdfBtn').addEventListener('click', saveAsPdf);

    // Gestione colori in tempo reale
    document.getElementById('borderColorPicker').addEventListener('input', (e) => {
      if (selectedNodeId) getNodeById(selectedNodeId).el.style.borderColor = e.target.value;
    });
    document.getElementById('textColorPicker').addEventListener('input', (e) => {
      if (selectedNodeId) {
        const n = getNodeById(selectedNodeId);
        if (n.type === 'text') n.el.querySelector('.node-content').style.color = e.target.value;
      }
    });
    document.getElementById('arrowColorPicker').addEventListener('input', (e) => {
      currentArrowColor = e.target.value;
      if (selectedConnectorId) connectors.find(c => c.id === selectedConnectorId).color = currentArrowColor;
      if (selectedFreeArrowId) freeArrows.find(a => a.id === selectedFreeArrowId).color = currentArrowColor;
      redrawCanvas();
    });

    // Avvio
    setMode('normal');

  </script>
</body>
</html>
