<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MindWeave</title>

  <style>
    :root {
      --bg: #0b0b0b;
      --panel: #111;
      --panel-2: #1a1a1a;
      --text: #eee;
      --muted: rgba(255,255,255,0.72);
      --border: #333;
      --border-2: #444;
      --accent: #66aaff;
      --btn: #111;
      --btn-active: #2c2c2c;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: var(--bg);
      color: var(--text);
      overflow: hidden;
    }

    header {
      position: relative;
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      background: var(--panel-2);
      border-bottom: 1px solid var(--border);
      flex-wrap: wrap;
      min-height: 52px;
      padding-left: 110px; /* spazio per bottone Index */
    }

    /* Link rapido all'index (root) */
    .home-link{
      position: absolute;
      left: 10px;
      top: 10px;
      z-index: 2000;
      text-decoration: none;
      font-size: 14px;
      font-weight: 700;
      padding: 6px 10px;
      border-radius: 8px;
      background: #111;
      color: #eee;
      border: 1px solid #444;
      user-select: none;
    }
    .home-link:hover{
      background:#222;
    }

    header input[type="color"] {
      width: 34px;
      height: 28px;
      border: 1px solid var(--border-2);
      border-radius: 6px;
      background: transparent;
      padding: 0;
      cursor: pointer;
    }

    header input[type="file"] {
      color: var(--text);
      max-width: 240px;
    }

    header input[type="text"],
    header textarea#textInput {
      border: 1px solid var(--border-2);
      background: var(--btn);
      color: var(--text);
      padding: 6px 8px;
      border-radius: 6px;
      min-height: 28px;
      font-size: 13px;
    }

    header textarea#textInput {
      resize: vertical;
      max-height: 90px;
      line-height: 1.2;
    }

    .group-label {
      font-size: 12px;
      color: var(--muted);
      margin-left: 6px;
      margin-right: 2px;
      user-select: none;
      white-space: nowrap;
    }

    .tool-btn {
      background: var(--btn);
      color: var(--text);
      border: 1px solid var(--border-2);
      border-radius: 6px;
      padding: 6px 8px;
      cursor: pointer;
      user-select: none;
      font-size: 13px;
      min-height: 28px;
    }

    .tool-btn:hover {
      background: #1b1b1b;
    }

    .tool-btn.active {
      background: var(--btn-active);
      border-color: #777;
    }

    .tool-select {
      border: 1px solid #444;
      background: #111;
      color: #eee;
      padding: 4px 6px;
      border-radius: 6px;
      font-size: 13px;
      min-height: 28px;
    }

    #workspace-wrapper {
      position: absolute;
      top: 52px;
      left: 0;
      right: 0;
      bottom: 24px;
      overflow: auto;
      background: #0b0b0b;
    }

    #workspace {
      position: relative;
      min-width: 1600px;
      min-height: 1200px;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: none;
    }

    .node {
      position: absolute;
      background: #1c1c1c;
      border: 1px solid #555;
      border-radius: 8px;
      padding: 8px 10px;
      min-width: 90px;
      min-height: 38px;
      cursor: move;
      user-select: none;
      box-shadow: 0 6px 18px rgba(0,0,0,0.25);
    }

    .node.selected {
      outline: 2px solid var(--accent);
    }

    .node-header {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-bottom: 6px;
      opacity: 0.9;
      user-select: none;
    }

    .node-type {
      font-size: 11px;
      padding: 2px 6px;
      border: 1px solid #444;
      border-radius: 999px;
      color: rgba(255,255,255,0.8);
    }

    .node-actions {
      margin-left: auto;
      display: flex;
      gap: 6px;
    }

    .node-actions button {
      border: 1px solid #444;
      background: #121212;
      color: #eee;
      border-radius: 6px;
      padding: 2px 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .node-actions button:hover { background: #1f1f1f; }

    .node-content {
      white-space: pre-wrap;
      outline: none;
      user-select: text;
      cursor: text;
    }

    .resize-handle {
      position: absolute;
      width: 12px;
      height: 12px;
      right: -6px;
      bottom: -6px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #0b0b0b;
      cursor: nwse-resize;
      display: none;
    }

    .node.selected .resize-handle { display: block; }

    #status-bar {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 24px;
      background: #1a1a1a;
      border-top: 1px solid #333;
      font-size: 12px;
      padding: 4px 8px;
      color: rgba(255,255,255,0.8);
      display: flex;
      align-items: center;
      gap: 10px;
    }

    /* WordArt */
    .wordart {
      font-weight: 800;
      letter-spacing: 0.5px;
    }
    .wordart-outline {
      -webkit-text-stroke: 2px rgba(0,0,0,0.65);
      text-stroke: 2px rgba(0,0,0,0.65);
      paint-order: stroke fill;
    }
    .wordart-shadow {
      text-shadow: 2px 2px 0 rgba(0,0,0,0.45), 6px 6px 14px rgba(0,0,0,0.25);
    }
    .wordart-neon {
      text-shadow: 0 0 6px rgba(0,0,0,0.4), 0 0 18px currentColor, 0 0 32px currentColor;
    }
    .wordart-gradient {
      background: linear-gradient(90deg, #ff6a00, #ee0979, #00c6ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent !important;
    }
  </style>
</head>

<body>
  <header>
    <!-- ‚úÖ Link all'index nel root -->
    <a href="index.html" class="home-link" title="Torna all'index">üè† Index</a>

    <span class="group-label">Nodo:</span>
    <button class="tool-btn" id="addBoxBtn" title="Crea nodo box">‚¨õ+</button>
    <button class="tool-btn" id="addCircleBtn" title="Crea nodo cerchio">‚ö™+</button>
    <button class="tool-btn" id="addImageBtn" title="Crea nodo immagine">üñºÔ∏è+</button>

    <span class="group-label">Testo:</span>
    <textarea id="textInput" placeholder="Scrivi testo nodo (Invio = a capo)" rows="1"></textarea>
    <button class="tool-btn" id="addTextBtn" title="Crea nodo di testo">üÖ£+</button>
    <button class="tool-btn" id="toggleWrapBtn" title="Testo a capo ON/OFF">‚Üî testo</button>

    <span class="group-label">Stile:</span>
    <select id="fontFamilySelect" class="tool-select" title="Carattere">
      <option value="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif">System</option>
      <option value="Georgia, 'Times New Roman', Times, serif">Serif</option>
      <option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Sans</option>
      <option value="'Courier New', Courier, monospace">Mono</option>
      <option value="'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', sans-serif">Trebuchet</option>
      <option value="'Palatino Linotype', Palatino, serif">Palatino</option>
    </select>
    <select id="fontSizeSelect" class="tool-select" title="Dimensione">
      <option value="12px">12</option>
      <option value="14px" selected>14</option>
      <option value="16px">16</option>
      <option value="18px">18</option>
      <option value="22px">22</option>
      <option value="28px">28</option>
      <option value="36px">36</option>
      <option value="48px">48</option>
    </select>
    <button class="tool-btn" id="boldBtn" title="Grassetto"><b>B</b></button>
    <button class="tool-btn" id="italicBtn" title="Corsivo"><i>I</i></button>
    <button class="tool-btn" id="underlineBtn" title="Sottolineato"><u>U</u></button>
    <button class="tool-btn" id="upperBtn" title="Maiuscolo (Grosseto)">AA</button>

    <span class="group-label">WordArt:</span>
    <select id="wordArtSelect" class="tool-select" title="Stile WordArt">
      <option value="none" selected>Nessuno</option>
      <option value="outline">Contorno</option>
      <option value="shadow">Ombra</option>
      <option value="neon">Neon</option>
      <option value="gradient">Gradiente</option>
    </select>
    <button class="tool-btn" id="addWordArtBtn" title="Crea testo WordArt">üé®+</button>

    <span class="group-label">Connessioni:</span>
    <button class="tool-btn" id="connectorModeBtn" title="Connettore">üîó</button>
    <button class="tool-btn" id="arrowModeBtn" title="Freccia">‚û°Ô∏è</button>
    <input type="color" id="arrowColorPicker" title="Colore linee/frecce" value="#66aaff" />

    <span class="group-label">Nodo:</span>
    <button class="tool-btn" id="resizeModeBtn">üî≥ Resize</button>
    <button class="tool-btn" id="panModeBtn" title="Sposta la lavagna">‚úã Sposta</button>

    <span class="group-label">File:</span>
    <button class="tool-btn" id="saveBtn" title="Salva progetto">üíæ Salva</button>
    <button class="tool-btn" id="loadBtn" title="Carica progetto">üìÇ Apri</button>
    <input type="file" id="loadFileInput" accept=".json" style="display:none" />
    <button class="tool-btn" id="exportBtn" title="Esporta PNG">üñºÔ∏è PNG</button>
    <button class="tool-btn" id="clearBtn" title="Pulisci">üßπ</button>
  </header>

  <div id="workspace-wrapper">
    <div id="workspace">
      <canvas id="canvas"></canvas>
    </div>
  </div>

  <div id="status-bar">
    <span id="statusText">Modalit√†: normal</span>
    <span style="opacity:.7">|</span>
    <span id="hintText" style="opacity:.7">Seleziona un nodo per modificarlo; ‚úã Sposta per trascinare la lavagna.</span>
  </div>

  <script>
    // ==========
    // RIFERIMENTI
    // ==========
    const workspaceWrapper = document.getElementById('workspace-wrapper');
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const statusBar = document.getElementById('statusText');

    // ==========
    // STATO
    // ==========
    let mode = 'normal'; // 'normal', 'connector', 'arrow', 'resizeNode', 'pan'
    let nodes = []; // { id, type, el }
    let connections = []; // { fromId, toId, color }
    let arrows = []; // { from: {x,y}, to: {x,y}, color }

    let selectedNodeId = null;

    // drag nodo
    let draggingNode = false;
    let dragNodePointerId = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    // resize nodo
    let resizingNode = false;
    let resizePointerId = null;
    let resizeStartW = 0;
    let resizeStartH = 0;
    let resizeStartX = 0;
    let resizeStartY = 0;

    // connettori
    let connectorStartNodeId = null;

    // frecce
    let drawingArrowStart = null;

    let currentArrowColor = document.getElementById('arrowColorPicker').value;

    // =========================
    // Stile testo (default + applicazione su nodo selezionato)
    // =========================
    const fontFamilySelect = document.getElementById('fontFamilySelect');
    const fontSizeSelect = document.getElementById('fontSizeSelect');
    const boldBtn = document.getElementById('boldBtn');
    const italicBtn = document.getElementById('italicBtn');
    const underlineBtn = document.getElementById('underlineBtn');
    const upperBtn = document.getElementById('upperBtn');
    const wordArtSelect = document.getElementById('wordArtSelect');
    const addWordArtBtn = document.getElementById('addWordArtBtn');

    const textStyle = {
      fontFamily: fontFamilySelect.value,
      fontSize: fontSizeSelect.value,
      fontWeight: '400',
      fontStyle: 'normal',
      textDecoration: 'none',
      textTransform: 'none',
      wordArt: 'none'
    };

    function getNodeById(id) {
      return nodes.find(n => n.id === id);
    }

    function syncControlsFromSelected() {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;

      const cs = window.getComputedStyle(contentEl);
      fontFamilySelect.value = contentEl.style.fontFamily || cs.fontFamily;
      fontSizeSelect.value = contentEl.style.fontSize || cs.fontSize;

      const fw = contentEl.style.fontWeight || cs.fontWeight;
      boldBtn.classList.toggle('active', fw !== '400' && fw !== 'normal');

      const fs = contentEl.style.fontStyle || cs.fontStyle;
      italicBtn.classList.toggle('active', fs === 'italic');

      const td = contentEl.style.textDecorationLine || cs.textDecorationLine;
      underlineBtn.classList.toggle('active', td === 'underline');

      const tt = contentEl.style.textTransform || cs.textTransform;
      upperBtn.classList.toggle('active', tt === 'uppercase');

      const wa = node.el.dataset.wordart || 'none';
      wordArtSelect.value = wa;
    }

    function applyTextFormattingToNode(node) {
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;

      contentEl.style.fontFamily = textStyle.fontFamily;
      contentEl.style.fontSize = textStyle.fontSize;
      contentEl.style.fontWeight = textStyle.fontWeight;
      contentEl.style.fontStyle = textStyle.fontStyle;
      contentEl.style.textDecoration = textStyle.textDecoration;
      contentEl.style.textTransform = textStyle.textTransform;

      node.el.dataset.wordart = textStyle.wordArt;

      contentEl.classList.remove('wordart','wordart-outline','wordart-shadow','wordart-neon','wordart-gradient');
      if (textStyle.wordArt !== 'none') {
        contentEl.classList.add('wordart');
        contentEl.classList.add('wordart-' + textStyle.wordArt);
      }
    }

    function applyFormattingToSelected() {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      applyTextFormattingToNode(node);
    }

    fontFamilySelect.addEventListener('change', () => {
      textStyle.fontFamily = fontFamilySelect.value;
      applyFormattingToSelected();
    });
    fontSizeSelect.addEventListener('change', () => {
      textStyle.fontSize = fontSizeSelect.value;
      applyFormattingToSelected();
    });
    boldBtn.addEventListener('click', () => {
      textStyle.fontWeight = (textStyle.fontWeight === '700') ? '400' : '700';
      boldBtn.classList.toggle('active', textStyle.fontWeight === '700');
      applyFormattingToSelected();
    });
    italicBtn.addEventListener('click', () => {
      textStyle.fontStyle = (textStyle.fontStyle === 'italic') ? 'normal' : 'italic';
      italicBtn.classList.toggle('active', textStyle.fontStyle === 'italic');
      applyFormattingToSelected();
    });
    underlineBtn.addEventListener('click', () => {
      textStyle.textDecoration = (textStyle.textDecoration === 'underline') ? 'none' : 'underline';
      underlineBtn.classList.toggle('active', textStyle.textDecoration === 'underline');
      applyFormattingToSelected();
    });
    upperBtn.addEventListener('click', () => {
      textStyle.textTransform = (textStyle.textTransform === 'uppercase') ? 'none' : 'uppercase';
      upperBtn.classList.toggle('active', textStyle.textTransform === 'uppercase');
      applyFormattingToSelected();
    });
    wordArtSelect.addEventListener('change', () => {
      textStyle.wordArt = wordArtSelect.value;
      applyFormattingToSelected();
    });
    addWordArtBtn.addEventListener('click', () => {
      const prev = textStyle.wordArt;
      if (textStyle.wordArt === 'none') textStyle.wordArt = 'outline';
      addTextNode(true);
      textStyle.wordArt = prev;
    });

    // ==========
    // UTILS
    // ==========
    function uid() {
      return Math.random().toString(16).slice(2) + Date.now().toString(16);
    }

    function setMode(newMode) {
      mode = newMode;
      updateToolbarState();
      statusBar.textContent = 'Modalit√†: ' + newMode;
      workspace.style.cursor = (newMode === 'pan') ? 'grab' : 'default';
    }

    function updateToolbarState() {
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

      if (mode === 'pan') {
        document.getElementById('panModeBtn').classList.add('active');
      }
      if (mode === 'connector') {
        document.getElementById('connectorModeBtn').classList.add('active');
      }
      if (mode === 'arrow') {
        document.getElementById('arrowModeBtn').classList.add('active');
      }
      if (mode === 'resizeNode') {
        document.getElementById('resizeModeBtn').classList.add('active');
      }
    }

    function resizeCanvas() {
      // Il canvas deve coprire tutta la superficie della lavagna (anche oltre la parte visibile)
      const w = Math.max(workspace.scrollWidth, workspace.clientWidth);
      const h = Math.max(workspace.scrollHeight, workspace.clientHeight);
      canvas.width = w;
      canvas.height = h;
      redrawCanvas();
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    function maybeGrowWorkspace() {
      const margin = 220;
      const nearRight = workspaceWrapper.scrollLeft + workspaceWrapper.clientWidth > workspace.scrollWidth - margin;
      const nearBottom = workspaceWrapper.scrollTop + workspaceWrapper.clientHeight > workspace.scrollHeight - margin;

      if (!nearRight && !nearBottom) return;

      const curW = Math.max(parseInt(getComputedStyle(workspace).minWidth) || workspace.scrollWidth, workspace.scrollWidth);
      const curH = Math.max(parseInt(getComputedStyle(workspace).minHeight) || workspace.scrollHeight, workspace.scrollHeight);

      const newW = nearRight ? Math.round(curW * 1.4) : curW;
      const newH = nearBottom ? Math.round(curH * 1.4) : curH;

      workspace.style.minWidth = newW + 'px';
      workspace.style.minHeight = newH + 'px';
      resizeCanvas();
    }

    function getTopmostNodeAt(x, y) {
      // x,y in coordinate workspace (includendo scroll)
      for (let i = nodes.length - 1; i >= 0; i--) {
        const n = nodes[i];
        const rect = n.el.getBoundingClientRect();
        const wsRect = workspace.getBoundingClientRect();

        const left = (rect.left - wsRect.left) + workspaceWrapper.scrollLeft;
        const top  = (rect.top - wsRect.top) + workspaceWrapper.scrollTop;

        const w = rect.width;
        const h = rect.height;

        if (x >= left && x <= left + w && y >= top && y <= top + h) {
          return n;
        }
      }
      return null;
    }

    function selectNode(id) {
      selectedNodeId = id;
      nodes.forEach(n => n.el.classList.toggle('selected', n.id === id));
      updateResizeHandles();
      redrawCanvas();
      syncControlsFromSelected();
    }

    function clearSelection() {
      selectedNodeId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    function updateResizeHandles() {
      nodes.forEach(n => {
        const handle = n.el.querySelector('.resize-handle');
        if (handle) {
          handle.style.display = (n.id === selectedNodeId) ? 'block' : 'none';
        }
      });
    }

    // ==========
    // DRAW CANVAS (connessioni + frecce)
    // ==========
    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // connessioni tra nodi (centro -> centro)
      connections.forEach(c => {
        const a = getNodeById(c.fromId);
        const b = getNodeById(c.toId);
        if (!a || !b) return;

        const ar = a.el.getBoundingClientRect();
        const br = b.el.getBoundingClientRect();
        const ws = workspace.getBoundingClientRect();

        const ax = (ar.left - ws.left) + workspaceWrapper.scrollLeft + ar.width / 2;
        const ay = (ar.top  - ws.top)  + workspaceWrapper.scrollTop  + ar.height / 2;

        const bx = (br.left - ws.left) + workspaceWrapper.scrollLeft + br.width / 2;
        const by = (br.top  - ws.top)  + workspaceWrapper.scrollTop  + br.height / 2;

        ctx.strokeStyle = c.color || currentArrowColor;
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(bx, by);
        ctx.stroke();
      });

      // frecce
      arrows.forEach(a => {
        const { from, to, color } = a;
        ctx.strokeStyle = color || currentArrowColor;
        ctx.fillStyle = color || currentArrowColor;
        ctx.lineWidth = 2;

        ctx.beginPath();
        ctx.moveTo(from.x, from.y);
        ctx.lineTo(to.x, to.y);
        ctx.stroke();

        // punta freccia
        const angle = Math.atan2(to.y - from.y, to.x - from.x);
        const headLen = 12;

        ctx.beginPath();
        ctx.moveTo(to.x, to.y);
        ctx.lineTo(to.x - headLen * Math.cos(angle - Math.PI / 6), to.y - headLen * Math.sin(angle - Math.PI / 6));
        ctx.lineTo(to.x - headLen * Math.cos(angle + Math.PI / 6), to.y - headLen * Math.sin(angle + Math.PI / 6));
        ctx.closePath();
        ctx.fill();
      });
    }

    // ==========
    // CREAZIONE NODI
    // ==========
    function createNodeElement(type, x, y, content) {
      const id = uid();

      const nodeEl = document.createElement('div');
      nodeEl.className = 'node';
      nodeEl.style.left = x + 'px';
      nodeEl.style.top  = y + 'px';
      nodeEl.dataset.id = id;
      nodeEl.dataset.type = type;

      // header
      const header = document.createElement('div');
      header.className = 'node-header';

      const chip = document.createElement('span');
      chip.className = 'node-type';
      chip.textContent = type;

      const actions = document.createElement('div');
      actions.className = 'node-actions';

      const delBtn = document.createElement('button');
      delBtn.textContent = '‚úñ';
      delBtn.title = 'Elimina nodo';
      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        removeNode(id);
      });

      actions.appendChild(delBtn);
      header.appendChild(chip);
      header.appendChild(actions);

      nodeEl.appendChild(header);

      // content
      if (type === 'text') {
        const contentEl = document.createElement('div');
        contentEl.className = 'node-content';
        contentEl.contentEditable = 'true';
        contentEl.spellcheck = false;
        contentEl.textContent = content || 'Testo';
        contentEl.style.whiteSpace = 'pre-wrap'; // default a capo
        nodeEl.appendChild(contentEl);

        // Applica stile corrente al nuovo nodo
        const nodeObjTemp = { type: 'text', el: nodeEl };
        applyTextFormattingToNode(nodeObjTemp);

      } else if (type === 'box') {
        const contentEl = document.createElement('div');
        contentEl.className = 'node-content';
        contentEl.contentEditable = 'true';
        contentEl.spellcheck = false;
        contentEl.textContent = content || 'Box';
        nodeEl.appendChild(contentEl);

      } else if (type === 'circle') {
        nodeEl.style.borderRadius = '999px';
        const contentEl = document.createElement('div');
        contentEl.className = 'node-content';
        contentEl.contentEditable = 'true';
        contentEl.spellcheck = false;
        contentEl.textContent = content || 'Cerchio';
        nodeEl.appendChild(contentEl);

      } else if (type === 'image') {
        const img = document.createElement('img');
        img.src = content || '';
        img.style.maxWidth = '240px';
        img.style.maxHeight = '160px';
        img.style.display = 'block';
        img.style.borderRadius = '8px';
        nodeEl.appendChild(img);
      }

      // resize handle
      const handle = document.createElement('div');
      handle.className = 'resize-handle';
      nodeEl.appendChild(handle);

      workspace.appendChild(nodeEl);

      const obj = { id, type, el: nodeEl };
      nodes.push(obj);

      // listeners
      nodeEl.addEventListener('pointerdown', (e) => onNodePointerDown(e, obj));
      handle.addEventListener('pointerdown', (e) => onResizeHandlePointerDown(e, obj));

      nodeEl.addEventListener('click', (e) => {
        e.stopPropagation();
        selectNode(id);
      });

      resizeCanvas();
      return obj;
    }

    function removeNode(id) {
      // rimuove connessioni
      connections = connections.filter(c => c.fromId !== id && c.toId !== id);

      const idx = nodes.findIndex(n => n.id === id);
      if (idx >= 0) {
        nodes[idx].el.remove();
        nodes.splice(idx, 1);
      }
      if (selectedNodeId === id) selectedNodeId = null;
      redrawCanvas();
    }

    // ==========
    // TESTO: crea nodo
    // ==========
    function addTextNode(forceWordArt = false) {
      const input = document.getElementById('textInput');
      const raw = (input.value || '').replace(/\r/g,'');
      const text = raw.trim() || 'Testo';
      if (forceWordArt && textStyle.wordArt === 'none') textStyle.wordArt = 'outline';
      createNodeElement('text', 50 + workspaceWrapper.scrollLeft, 50 + workspaceWrapper.scrollTop, text);
      input.value = '';
      input.style.height = 'auto';
    }

    // ==========
    // EVENTI WORKSPACE
    // ==========
    // Pan (spostamento lavagna)
    let panning = false;
    let panPointerId = null;
    let panStartX = 0;
    let panStartY = 0;
    let panStartScrollLeft = 0;
    let panStartScrollTop = 0;

    function onWorkspacePointerDown(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = (e.clientX - wsRect.left) + workspaceWrapper.scrollLeft;
      const y = (e.clientY - wsRect.top) + workspaceWrapper.scrollTop;

      // Modalit√† PAN: trascina la lavagna (non i nodi)
      if (mode === 'pan') {
        e.preventDefault();
        panning = true;
        panPointerId = e.pointerId;
        workspace.setPointerCapture(e.pointerId);
        workspace.style.cursor = 'grabbing';
        panStartX = e.clientX;
        panStartY = e.clientY;
        panStartScrollLeft = workspaceWrapper.scrollLeft;
        panStartScrollTop = workspaceWrapper.scrollTop;
        return;
      }

      // click su vuoto -> selezione nulla
      const hit = getTopmostNodeAt(x, y);
      if (!hit) {
        clearSelection();
      }

      // frecce: se stai disegnando
      if (mode === 'arrow') {
        if (!drawingArrowStart) {
          drawingArrowStart = { x, y };
        } else {
          arrows.push({ from: drawingArrowStart, to: { x, y }, color: currentArrowColor });
          drawingArrowStart = null;
          redrawCanvas();
        }
      }
    }

    function onWorkspacePointerMove(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = (e.clientX - wsRect.left) + workspaceWrapper.scrollLeft;
      const y = (e.clientY - wsRect.top) + workspaceWrapper.scrollTop;

      if (panning && e.pointerId === panPointerId) {
        e.preventDefault();
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        workspaceWrapper.scrollLeft = panStartScrollLeft - dx;
        workspaceWrapper.scrollTop  = panStartScrollTop  - dy;
        maybeGrowWorkspace();
        return;
      }

      // trascinamento nodo
      if (draggingNode && e.pointerId === dragNodePointerId && selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        node.el.style.left = (x - dragOffsetX) + 'px';
        node.el.style.top  = (y - dragOffsetY) + 'px';
        redrawCanvas();
        maybeGrowWorkspace();
      }

      // resize nodo
      if (resizingNode && e.pointerId === resizePointerId && selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        const newW = Math.max(90, resizeStartW + (x - resizeStartX));
        const newH = Math.max(38, resizeStartH + (y - resizeStartY));
        node.el.style.width = newW + 'px';
        node.el.style.height = newH + 'px';
        redrawCanvas();
        maybeGrowWorkspace();
      }
    }

    function onWorkspacePointerUp(e) {
      if (panning && e.pointerId === panPointerId) {
        panning = false;
        panPointerId = null;
        try { workspace.releasePointerCapture(e.pointerId); } catch(_) {}
        workspace.style.cursor = 'grab';
        maybeGrowWorkspace();
      }

      if (draggingNode && e.pointerId === dragNodePointerId) {
        draggingNode = false;
        dragNodePointerId = null;
      }
      if (resizingNode && e.pointerId === resizePointerId) {
        resizingNode = false;
        resizePointerId = null;
      }
    }

    workspace.addEventListener('pointerdown', onWorkspacePointerDown);
    workspace.addEventListener('pointermove', onWorkspacePointerMove);
    workspace.addEventListener('pointerup', onWorkspacePointerUp);
    workspace.addEventListener('click', (e) => {
      // click sullo sfondo
      if (e.target === workspace || e.target === canvas) {
        clearSelection();
      }
    });

    // ==========
    // EVENTI NODO
    // ==========
    function onNodePointerDown(e, node) {
      // se pan attivo: non trascino nodi
      if (mode === 'pan') return;

      // se click su handle o action, ignora
      if (e.target.classList.contains('resize-handle')) return;

      // seleziona
      selectNode(node.id);

      const wsRect = workspace.getBoundingClientRect();
      const nodeRect = node.el.getBoundingClientRect();

      const x = (e.clientX - wsRect.left) + workspaceWrapper.scrollLeft;
      const y = (e.clientY - wsRect.top) + workspaceWrapper.scrollTop;

      // modalit√† connettore
      if (mode === 'connector') {
        if (!connectorStartNodeId) {
          connectorStartNodeId = node.id;
        } else if (connectorStartNodeId !== node.id) {
          connections.push({ fromId: connectorStartNodeId, toId: node.id, color: currentArrowColor });
          connectorStartNodeId = null;
          redrawCanvas();
        }
        return;
      }

      // drag nodo normale
      draggingNode = true;
      dragNodePointerId = e.pointerId;
      workspace.setPointerCapture(e.pointerId);

      dragOffsetX = x - ((nodeRect.left - wsRect.left) + workspaceWrapper.scrollLeft);
      dragOffsetY = y - ((nodeRect.top  - wsRect.top)  + workspaceWrapper.scrollTop);
    }

    function onResizeHandlePointerDown(e, node) {
      if (mode !== 'resizeNode') return;
      e.stopPropagation();
      selectNode(node.id);

      resizingNode = true;
      resizePointerId = e.pointerId;
      workspace.setPointerCapture(e.pointerId);

      const wsRect = workspace.getBoundingClientRect();
      const rect = node.el.getBoundingClientRect();

      const x = (e.clientX - wsRect.left) + workspaceWrapper.scrollLeft;
      const y = (e.clientY - wsRect.top)  + workspaceWrapper.scrollTop;

      resizeStartW = rect.width;
      resizeStartH = rect.height;
      resizeStartX = x;
      resizeStartY = y;
    }

    // ==========
    // TOOLBAR LISTENERS
    // ==========
    document.getElementById('addBoxBtn').addEventListener('click', () => {
      createNodeElement('box', 50 + workspaceWrapper.scrollLeft, 50 + workspaceWrapper.scrollTop, 'Box');
    });

    document.getElementById('addCircleBtn').addEventListener('click', () => {
      createNodeElement('circle', 50 + workspaceWrapper.scrollLeft, 50 + workspaceWrapper.scrollTop, 'Cerchio');
    });

    document.getElementById('addImageBtn').addEventListener('click', () => {
      const url = prompt('Inserisci URL immagine (https://...)');
      if (!url) return;
      createNodeElement('image', 50 + workspaceWrapper.scrollLeft, 50 + workspaceWrapper.scrollTop, url);
    });

    document.getElementById('addTextBtn').addEventListener('click', () => addTextNode(false));

    // Textarea: autosize + Ctrl/‚åò+Invio per creare nodo
    const textInputEl = document.getElementById('textInput');
    textInputEl.addEventListener('input', () => {
      textInputEl.style.height = 'auto';
      textInputEl.style.height = Math.min(90, textInputEl.scrollHeight) + 'px';
    });
    textInputEl.addEventListener('keydown', (e) => {
      const isCmd = e.metaKey || e.ctrlKey;
      if (isCmd && e.key === 'Enter') {
        e.preventDefault();
        addTextNode(false);
      }
    });

    // wrap toggle
    let wrapEnabled = true;
    document.getElementById('toggleWrapBtn').addEventListener('click', () => {
      wrapEnabled = !wrapEnabled;
      // applica a nodo selezionato se text
      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (node && node.type === 'text') {
          const contentEl = node.el.querySelector('.node-content');
          if (contentEl) {
            contentEl.style.whiteSpace = wrapEnabled ? 'pre-wrap' : 'pre';
          }
        }
      }
    });

    // connettore / freccia / resize / pan
    document.getElementById('connectorModeBtn').addEventListener('click', () => {
      connectorStartNodeId = null;
      drawingArrowStart = null;
      setMode(mode === 'connector' ? 'normal' : 'connector');
    });

    document.getElementById('arrowModeBtn').addEventListener('click', () => {
      connectorStartNodeId = null;
      drawingArrowStart = null;
      setMode(mode === 'arrow' ? 'normal' : 'arrow');
    });

    document.getElementById('panModeBtn').addEventListener('click', () => {
      if (mode === 'pan') setMode('normal');
      else {
        drawingArrowStart = null;
        connectorStartNodeId = null;
        setMode('pan');
      }
    });

    document.getElementById('resizeModeBtn').addEventListener('click', () => {
      connectorStartNodeId = null;
      drawingArrowStart = null;
      setMode(mode === 'resizeNode' ? 'normal' : 'resizeNode');
    });

    document.getElementById('arrowColorPicker').addEventListener('change', (e) => {
      currentArrowColor = e.target.value;
    });

    // ==========
    // SALVA / CARICA / EXPORT / CLEAR
    // ==========
    function serializeState() {
      const wsRect = workspace.getBoundingClientRect();
      const serializedNodes = nodes.map(n => {
        const rect = n.el.getBoundingClientRect();
        const left = (rect.left - wsRect.left) + workspaceWrapper.scrollLeft;
        const top  = (rect.top  - wsRect.top)  + workspaceWrapper.scrollTop;

        const base = {
          id: n.id,
          type: n.type,
          x: left,
          y: top,
          w: rect.width,
          h: rect.height
        };

        if (n.type === 'image') {
          const img = n.el.querySelector('img');
          base.src = img ? img.src : '';
          return base;
        }

        const contentEl = n.el.querySelector('.node-content');
        if (contentEl) {
          const cs = window.getComputedStyle(contentEl);
          base.text = contentEl.textContent || '';
          base.textColor = cs.color;
          base.fontSize = cs.fontSize;
          base.fontFamily = cs.fontFamily;
          base.fontWeight = cs.fontWeight;
          base.fontStyle = cs.fontStyle;
          base.textDecoration = cs.textDecorationLine;
          base.textTransform = cs.textTransform;
          base.textAlign = cs.textAlign;
          base.whiteSpace = cs.whiteSpace;
          base.wordArt = n.el.dataset.wordart || 'none';
        }
        return base;
      });

      return {
        version: 1,
        workspace: {
          minWidth: workspace.style.minWidth || '',
          minHeight: workspace.style.minHeight || '',
          scrollLeft: workspaceWrapper.scrollLeft,
          scrollTop: workspaceWrapper.scrollTop
        },
        nodes: serializedNodes,
        connections,
        arrows
      };
    }

    function downloadJSON(filename, data) {
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    document.getElementById('saveBtn').addEventListener('click', () => {
      const state = serializeState();
      downloadJSON('mindweave.json', state);
    });

    document.getElementById('loadBtn').addEventListener('click', () => {
      document.getElementById('loadFileInput').click();
    });

    document.getElementById('loadFileInput').addEventListener('change', async (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;
      const text = await file.text();
      try {
        const data = JSON.parse(text);
        loadState(data);
      } catch (err) {
        alert('File non valido.');
      } finally {
        e.target.value = '';
      }
    });

    function loadState(data) {
      // pulisci
      nodes.forEach(n => n.el.remove());
      nodes = [];
      connections = [];
      arrows = [];
      clearSelection();

      // workspace size + scroll
      if (data.workspace) {
        if (data.workspace.minWidth) workspace.style.minWidth = data.workspace.minWidth;
        if (data.workspace.minHeight) workspace.style.minHeight = data.workspace.minHeight;
      }

      // nodes
      (data.nodes || []).forEach(sn => {
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node';
        nodeEl.style.left = (sn.x || 0) + 'px';
        nodeEl.style.top  = (sn.y || 0) + 'px';
        nodeEl.style.width = (sn.w || 120) + 'px';
        nodeEl.style.height = (sn.h || 60) + 'px';
        nodeEl.dataset.id = sn.id;
        nodeEl.dataset.type = sn.type;

        // header
        const header = document.createElement('div');
        header.className = 'node-header';

        const chip = document.createElement('span');
        chip.className = 'node-type';
        chip.textContent = sn.type;

        const actions = document.createElement('div');
        actions.className = 'node-actions';

        const delBtn = document.createElement('button');
        delBtn.textContent = '‚úñ';
        delBtn.title = 'Elimina nodo';
        delBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          removeNode(sn.id);
        });

        actions.appendChild(delBtn);
        header.appendChild(chip);
        header.appendChild(actions);

        nodeEl.appendChild(header);

        if (sn.type === 'image') {
          const img = document.createElement('img');
          img.src = sn.src || '';
          img.style.maxWidth = '240px';
          img.style.maxHeight = '160px';
          img.style.display = 'block';
          img.style.borderRadius = '8px';
          nodeEl.appendChild(img);
        } else {
          const contentEl = document.createElement('div');
          contentEl.className = 'node-content';
          contentEl.contentEditable = 'true';
          contentEl.spellcheck = false;
          contentEl.textContent = sn.text || '';
          if (sn.textColor) contentEl.style.color = sn.textColor;
          if (sn.fontSize) contentEl.style.fontSize = sn.fontSize;
          if (sn.fontFamily) contentEl.style.fontFamily = sn.fontFamily;
          if (sn.fontWeight) contentEl.style.fontWeight = sn.fontWeight;
          if (sn.fontStyle) contentEl.style.fontStyle = sn.fontStyle;
          if (sn.textDecoration) contentEl.style.textDecoration = sn.textDecoration;
          if (sn.textTransform) contentEl.style.textTransform = sn.textTransform;
          if (sn.textAlign) contentEl.style.textAlign = sn.textAlign;
          if (sn.whiteSpace) contentEl.style.whiteSpace = sn.whiteSpace;
          nodeEl.dataset.wordart = sn.wordArt || 'none';

          contentEl.classList.remove('wordart','wordart-outline','wordart-shadow','wordart-neon','wordart-gradient');
          if ((sn.wordArt || 'none') !== 'none') {
            contentEl.classList.add('wordart');
            contentEl.classList.add('wordart-' + sn.wordArt);
          }

          nodeEl.appendChild(contentEl);

          if (sn.type === 'circle') nodeEl.style.borderRadius = '999px';
        }

        const handle = document.createElement('div');
        handle.className = 'resize-handle';
        nodeEl.appendChild(handle);

        workspace.appendChild(nodeEl);

        const obj = { id: sn.id, type: sn.type, el: nodeEl };
        nodes.push(obj);

        nodeEl.addEventListener('pointerdown', (ev) => onNodePointerDown(ev, obj));
        handle.addEventListener('pointerdown', (ev) => onResizeHandlePointerDown(ev, obj));
        nodeEl.addEventListener('click', (ev) => {
          ev.stopPropagation();
          selectNode(sn.id);
        });
      });

      connections = data.connections || [];
      arrows = data.arrows || [];

      resizeCanvas();

      if (data.workspace) {
        workspaceWrapper.scrollLeft = data.workspace.scrollLeft || 0;
        workspaceWrapper.scrollTop  = data.workspace.scrollTop || 0;
      }

      redrawCanvas();
    }

    document.getElementById('exportBtn').addEventListener('click', async () => {
      // esporta screenshot (workspace visibile)
      const exportCanvas = document.createElement('canvas');
      exportCanvas.width = workspaceWrapper.clientWidth;
      exportCanvas.height = workspaceWrapper.clientHeight;
      const ex = exportCanvas.getContext('2d');

      // sfondo
      ex.fillStyle = '#0b0b0b';
      ex.fillRect(0, 0, exportCanvas.width, exportCanvas.height);

      // disegna linee dal canvas principale "ritagliate" alla viewport
      ex.drawImage(
        canvas,
        workspaceWrapper.scrollLeft, workspaceWrapper.scrollTop,
        exportCanvas.width, exportCanvas.height,
        0, 0,
        exportCanvas.width, exportCanvas.height
      );

      // rasterizza nodi via HTML2Canvas? no: facciamo export semplice delle connessioni.
      // (Per export completo dei nodi servirebbe una lib; qui mantenuto behavior originale)
      const url = exportCanvas.toDataURL('image/png');
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mindweave.png';
      a.click();
    });

    document.getElementById('clearBtn').addEventListener('click', () => {
      if (!confirm('Sicuro di pulire tutto?')) return;
      nodes.forEach(n => n.el.remove());
      nodes = [];
      connections = [];
      arrows = [];
      clearSelection();
      redrawCanvas();
    });

    // ==========
    // INIT
    // ==========
    updateToolbarState();
    resizeCanvas();
  </script>
</body>
</html>
