<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>MindWeave â€“ Lavagna concettuale</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />

  <!-- Librerie per esportazione -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    html {
      height: 100%;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f5f5f5;
      display: flex;
      flex-direction: column;

      /* âœ… FIX iPad/Safari: evita tagli della toolbar con viewport dinamico + safe-area */
      height: 100vh;
      height: 100dvh;
      padding-top: env(safe-area-inset-top, 0px);

      overflow: hidden;
    }

    header {
      flex: 0 0 auto;
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 4px;
      padding: 6px 8px;
      background: #222;
      color: #f5f5f5;
      font-size: 14px;

      /* âœ… FIX: resta sempre visibile e non viene "mangiata" in alto */
      position: sticky;
      top: 0;
      z-index: 999;
    }

    header span.group-label {
      font-weight: 600;
      margin: 0 4px;
    }

    header input[type="text"],
    header textarea#textInput {
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #444;
      min-width: 120px;
      font-size: 14px;
      background: #111;
      color: #eee;
    }

    header textarea#textInput {
      resize: vertical;
      max-height: 90px;
      line-height: 1.2;
    }

    header input[type="file"] {
      font-size: 12px;
    }

    header input[type="color"] {
      width: 28px;
      height: 28px;
      padding: 0;
      border-radius: 4px;
      border: 1px solid #555;
      background: #111;
    }

    .tool-btn {
      border: 1px solid #444;
      background: #333;
      color: #eee;
      padding: 4px 6px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      min-height: 28px;
    }

    .tool-btn:hover {
      background: #444;
    }

    .tool-btn.active {
      background: #007acc;
      border-color: #00aaff;
      color: #fff;
    }

    #workspace-wrapper {
      flex: 1 1 auto;
      padding: 6px;
      overflow: auto;
      background: #ddd;
    }

    #workspace {
      position: relative;
      min-width: 1600px;
      min-height: 1200px;
      margin: 0 auto;
      background: #fdfdfd;
      border-radius: 8px;
      box-shadow: 0 0 8px rgba(0,0,0,0.25);
      touch-action: none;
    }

    #connectorCanvas {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .node {
      position: absolute;
      min-width: 80px;
      min-height: 40px;
      padding: 6px;
      border-radius: 6px;
      border: 2px solid #666;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      touch-action: none;
      pointer-events: auto;
    }

    .node.selected {
      box-shadow: 0 0 0 2px #007acc;
    }

    .text-node {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .node-content {
      width: 100%;
      min-height: 28px;
      outline: none;
      font-size: 14px;
      white-space: pre-wrap;       /* default: va a capo */
      word-wrap: break-word;
      text-align: center;          /* testo centrato nel riquadro */
    }

    .image-node img {
      display: block;
      max-width: 100%;
      height: auto;
      border-radius: 4px;
    }

    /* Maniglie di ridimensionamento */
    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      background: #007acc;
      border-radius: 50%;
      border: 1px solid #fff;
      box-shadow: 0 0 0 1px #007acc;
      touch-action: none;
    }

    .resize-handle.tl {
      top: -6px;
      left: -6px;
      cursor: nwse-resize;
    }

    .resize-handle.tr {
      top: -6px;
      right: -6px;
      cursor: nesw-resize;
    }

    .resize-handle.bl {
      bottom: -6px;
      left: -6px;
      cursor: nesw-resize;
    }

    .resize-handle.br {
      bottom: -6px;
      right: -6px;
      cursor: nwse-resize;
    }

    #status-bar {
      flex: 0 0 auto;
      padding: 4px 8px;
      background: #111;
      color: #ccc;
      font-size: 12px;
    }

    @media (max-width: 768px) {
      header {
        font-size: 12px;
      }
      .tool-btn {
        font-size: 12px;
        padding: 3px 4px;
      }
      header input[type="text"],
    header textarea#textInput {
        min-width: 100px;
      }
    }
  
    .tool-select {
      border: 1px solid #444;
      background: #111;
      color: #eee;
      padding: 4px 6px;
      border-radius: 4px;
      font-size: 13px;
      min-height: 28px;
    }

    .wordart {
      font-weight: 800;
      letter-spacing: 0.5px;
    }
    .wordart-outline {
      -webkit-text-stroke: 2px rgba(0,0,0,0.65);
      text-stroke: 2px rgba(0,0,0,0.65);
      paint-order: stroke fill;
    }
    .wordart-shadow {
      text-shadow: 2px 2px 0 rgba(0,0,0,0.45), 6px 6px 14px rgba(0,0,0,0.25);
    }
    .wordart-neon {
      text-shadow: 0 0 6px rgba(0,0,0,0.4), 0 0 18px currentColor, 0 0 32px currentColor;
    }
    .wordart-gradient {
      background: linear-gradient(90deg, #ff6a00, #ee0979, #00c6ff);
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent !important;
    }

  </style>
</head>
<body>
  <header>
    <span class="group-label">Testo:</span>
    <textarea id="textInput" placeholder="Scrivi testo nodo (Invio = a capo)" rows="1"></textarea>
    <button class="tool-btn" id="addTextBtn" title="Crea nodo di testo">ðŸ…£+</button>
    <button class="tool-btn" id="toggleWrapBtn" title="Testo a capo ON/OFF">â†” testo</button>

    <span class="group-label">Stile:</span>
    <select id="fontFamilySelect" class="tool-select" title="Carattere">
      <option value="system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif">System</option>
      <option value="Georgia, 'Times New Roman', Times, serif">Serif</option>
      <option value="'Segoe UI', Tahoma, Geneva, Verdana, sans-serif">Sans</option>
      <option value="'Courier New', Courier, monospace">Mono</option>
      <option value="'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', sans-serif">Trebuchet</option>
      <option value="'Palatino Linotype', Palatino, serif">Palatino</option>
    </select>
    <select id="fontSizeSelect" class="tool-select" title="Dimensione">
      <option value="12px">12</option>
      <option value="14px" selected>14</option>
      <option value="16px">16</option>
      <option value="18px">18</option>
      <option value="22px">22</option>
      <option value="28px">28</option>
      <option value="36px">36</option>
      <option value="48px">48</option>
    </select>
    <button class="tool-btn" id="boldBtn" title="Grassetto"><b>B</b></button>
    <button class="tool-btn" id="italicBtn" title="Corsivo"><i>I</i></button>
    <button class="tool-btn" id="underlineBtn" title="Sottolineato"><u>U</u></button>
    <button class="tool-btn" id="upperBtn" title="Maiuscolo (Grosseto)">AA</button>

    <span class="group-label">WordArt:</span>
    <select id="wordArtSelect" class="tool-select" title="Stile WordArt">
      <option value="none" selected>Nessuno</option>
      <option value="outline">Contorno</option>
      <option value="shadow">Ombra</option>
      <option value="neon">Neon</option>
      <option value="gradient">Gradiente</option>
    </select>
    <button class="tool-btn" id="addWordArtBtn" title="Crea testo WordArt">ðŸŽ¨+</button>


    <span class="group-label">Immagine:</span>
    <input type="file" id="imageInput" accept="image/*" />
    <button class="tool-btn" id="addImageBtn">ðŸ–¼+</button>

    <span class="group-label">Nodo:</span>
    <button class="tool-btn" id="resizeModeBtn">ðŸ”³ Resize</button>
    <button class="tool-btn" id="panModeBtn" title="Sposta la lavagna">âœ‹ Sposta</button>
    <button class="tool-btn" id="nodePlusBtn">â–¡+</button>
    <button class="tool-btn" id="nodeMinusBtn">â–¡âˆ’</button>

    <span class="group-label">Connettori:</span>
    <button class="tool-btn" id="connectorModeBtn">â–¡â†’â–¡</button>

    <span class="group-label">Frecce:</span>
    <button class="tool-btn" id="arrowModeBtn">âžœ</button>
    <button class="tool-btn" id="arrowLengthPlusBtn">â†”+</button>
    <button class="tool-btn" id="arrowLengthMinusBtn">â†”âˆ’</button>
    <button class="tool-btn" id="arrowRotateLeftBtn">ðŸ”„âˆ’</button>
    <button class="tool-btn" id="arrowRotateRightBtn">ðŸ”„+</button>

    <span class="group-label">Colori:</span>
    <label title="Bordo nodo">ðŸ–¼</label><input type="color" id="borderColorPicker" value="#666666" />
    <label title="Testo nodo">A</label><input type="color" id="textColorPicker" value="#000000" />
    <label title="Freccia">â†’</label><input type="color" id="arrowColorPicker" value="#0000ff" />

    <span class="group-label">Livello:</span>
    <button class="tool-btn" id="bringToFrontBtn" title="Porta in primo piano">â¬† Primo</button>
    <button class="tool-btn" id="sendToBackBtn" title="Manda dietro">â¬‡ Dietro</button>

    <span class="group-label">Azioni:</span>
    <button class="tool-btn" id="savePngStandardBtn">ðŸ“¸ PNG</button>
    <button class="tool-btn" id="savePngHQBtn" title="PNG qualitÃ  massima">ðŸ“¸ PNG HQ</button>
    <button class="tool-btn" id="savePdfBtn">ðŸ“„ PDF</button>
    <button class="tool-btn" id="deleteSelectedBtn">ðŸ—‘ Cancella</button>
    <button class="tool-btn" id="clearAllBtn">ðŸ§¹ Tutto</button>
    <button class="tool-btn" id="saveBoardBtn">ðŸ’¾ Salva</button>
    <button class="tool-btn" id="loadBoardBtn">ðŸ“‚ Apri</button>
    <input type="file" id="loadBoardInput" accept=".json" style="display:none" />
  </header>

  <div id="workspace-wrapper">
    <div id="workspace">
      <canvas id="connectorCanvas"></canvas>
      <!-- Nodi creati dinamicamente -->
    </div>
  </div>

  <div id="status-bar">ModalitÃ : normal</div>

  <script>
    // =========================
    // Stato globale
    // =========================
    const workspaceWrapper = document.getElementById('workspace-wrapper');
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('connectorCanvas');
    const ctx = canvas.getContext('2d');

    let mode = 'normal'; // 'normal', 'connector', 'arrow', 'resizeNode', 'pan'
    let nodes = [];       // {id, el, type, x, y, z}
    let connectors = [];  // {id, fromId, toId, color, z}
    let freeArrows = [];  // {id, cx, cy, length, angle, color, z}
    let nextId = 1;

    let selectedNodeId = null;
    let selectedConnectorId = null;
    let selectedFreeArrowId = null;

    let connectorStartNodeId = null;

    let draggingNode = null;
    let dragNodePointerId = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;


    // Pan (spostamento lavagna)
    let panning = false;
    let panPointerId = null;
    let panStartX = 0;
    let panStartY = 0;
    let panStartScrollLeft = 0;
    let panStartScrollTop = 0;

    let resizingNode = null;
    let resizeCorner = null;
    let resizeStart = null; // {x,y,width,height,left,top,aspect}

    let drawingArrowStart = null; // {x,y}

    let draggingFreeArrowId = null;
    let dragArrowStart = null; // {pointerX, pointerY, cx, cy}
    let dragArrowPointerId = null;

    let currentArrowColor = document.getElementById('arrowColorPicker').value;

    // =========================
    // Stile testo (default + applicazione su nodo selezionato)
    // =========================
    const fontFamilySelect = document.getElementById('fontFamilySelect');
    const fontSizeSelect = document.getElementById('fontSizeSelect');
    const boldBtn = document.getElementById('boldBtn');
    const italicBtn = document.getElementById('italicBtn');
    const underlineBtn = document.getElementById('underlineBtn');
    const upperBtn = document.getElementById('upperBtn');
    const wordArtSelect = document.getElementById('wordArtSelect');
    const addWordArtBtn = document.getElementById('addWordArtBtn');

    const textStyle = {
      fontFamily: fontFamilySelect.value,
      fontSize: fontSizeSelect.value,
      fontWeight: '400',
      fontStyle: 'normal',
      textDecoration: 'none',
      textTransform: 'none',
      wordArt: 'none'
    };

    function syncControlsFromSelected() {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      const cs = window.getComputedStyle(contentEl);
      fontFamilySelect.value = contentEl.style.fontFamily || cs.fontFamily;
      fontSizeSelect.value = contentEl.style.fontSize || cs.fontSize;
      boldBtn.classList.toggle('active', (contentEl.style.fontWeight || cs.fontWeight) !== '400' && (contentEl.style.fontWeight || cs.fontWeight) !== 'normal');
      italicBtn.classList.toggle('active', (contentEl.style.fontStyle || cs.fontStyle) === 'italic');
      underlineBtn.classList.toggle('active', (contentEl.style.textDecorationLine || cs.textDecorationLine) === 'underline');
      upperBtn.classList.toggle('active', (contentEl.style.textTransform || cs.textTransform) === 'uppercase');

      const wa = node.el.dataset.wordart || 'none';
      wordArtSelect.value = wa;
    }

    function applyTextFormattingToNode(node) {
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;

      // base
      contentEl.style.fontFamily = textStyle.fontFamily;
      contentEl.style.fontSize = textStyle.fontSize;
      contentEl.style.fontWeight = textStyle.fontWeight;
      contentEl.style.fontStyle = textStyle.fontStyle;
      contentEl.style.textDecoration = textStyle.textDecoration;
      contentEl.style.textTransform = textStyle.textTransform;

      // WordArt (su container per classi, cosÃ¬ si salva piÃ¹ facilmente)
      node.el.dataset.wordart = textStyle.wordArt;
      contentEl.classList.remove('wordart','wordart-outline','wordart-shadow','wordart-neon','wordart-gradient');
      if (textStyle.wordArt !== 'none') {
        contentEl.classList.add('wordart');
        contentEl.classList.add('wordart-' + textStyle.wordArt);
      }
    }

    function applyFormattingToSelected() {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      applyTextFormattingToNode(node);
    }

    // Controlli UI
    fontFamilySelect.addEventListener('change', () => {
      textStyle.fontFamily = fontFamilySelect.value;
      applyFormattingToSelected();
    });
    fontSizeSelect.addEventListener('change', () => {
      textStyle.fontSize = fontSizeSelect.value;
      applyFormattingToSelected();
    });
    boldBtn.addEventListener('click', () => {
      textStyle.fontWeight = (textStyle.fontWeight === '700') ? '400' : '700';
      boldBtn.classList.toggle('active', textStyle.fontWeight === '700');
      applyFormattingToSelected();
    });
    italicBtn.addEventListener('click', () => {
      textStyle.fontStyle = (textStyle.fontStyle === 'italic') ? 'normal' : 'italic';
      italicBtn.classList.toggle('active', textStyle.fontStyle === 'italic');
      applyFormattingToSelected();
    });
    underlineBtn.addEventListener('click', () => {
      textStyle.textDecoration = (textStyle.textDecoration === 'underline') ? 'none' : 'underline';
      underlineBtn.classList.toggle('active', textStyle.textDecoration === 'underline');
      applyFormattingToSelected();
    });
    upperBtn.addEventListener('click', () => {
      textStyle.textTransform = (textStyle.textTransform === 'uppercase') ? 'none' : 'uppercase';
      upperBtn.classList.toggle('active', textStyle.textTransform === 'uppercase');
      applyFormattingToSelected();
    });

    wordArtSelect.addEventListener('change', () => {
      textStyle.wordArt = wordArtSelect.value;
      applyFormattingToSelected();
    });

    addWordArtBtn.addEventListener('click', () => {
      const prev = textStyle.wordArt;
      if (textStyle.wordArt === 'none') textStyle.wordArt = 'outline';
      addTextNode(true); // wordart node
      textStyle.wordArt = prev;
    });

    const statusBar = document.getElementById('status-bar');

    // z-index per nodi (HTML) e per oggetti sul canvas (frecce + connettori)
    let nodeZCounter = 10;
    let canvasZCounter = 1;

    // =========================
    // Utility ID
    // =========================
    function generateId() {
      return nextId++;
    }

    // =========================
    // Canvas resize
    // =========================
    function resizeCanvas() {
      // Il canvas deve coprire tutta la superficie della lavagna (anche oltre la parte visibile)
      const w = Math.max(workspace.scrollWidth, workspace.clientWidth);
      const h = Math.max(workspace.scrollHeight, workspace.clientHeight);
      canvas.width = w;
      canvas.height = h;
      redrawCanvas();
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    function maybeGrowWorkspace() {
      const margin = 220;
      const nearRight = workspaceWrapper.scrollLeft + workspaceWrapper.clientWidth > workspace.scrollWidth - margin;
      const nearBottom = workspaceWrapper.scrollTop + workspaceWrapper.clientHeight > workspace.scrollHeight - margin;

      if (!nearRight && !nearBottom) return;

      const currentW = Math.max(parseInt(getComputedStyle(workspace).minWidth) || 0, workspace.scrollWidth);
      const currentH = Math.max(parseInt(getComputedStyle(workspace).minHeight) || 0, workspace.scrollHeight);

      const newW = nearRight ? Math.round(currentW * 1.35) : currentW;
      const newH = nearBottom ? Math.round(currentH * 1.35) : currentH;

      workspace.style.minWidth = newW + 'px';
      workspace.style.minHeight = newH + 'px';
      resizeCanvas();
    }

    // =========================
    // ModalitÃ 
    // =========================
    function setMode(newMode) {
      mode = newMode;
      updateToolbarState();
      updateResizeHandles();
      statusBar.textContent = 'ModalitÃ : ' + newMode;
      workspace.style.cursor = (newMode === 'pan') ? 'grab' : 'default';
    }

    function updateToolbarState() {
      document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));

      if (mode === 'pan') {
        document.getElementById('panModeBtn').classList.add('active');
      }
      if (mode === 'connector') {
        document.getElementById('connectorModeBtn').classList.add('active');
      } else if (mode === 'arrow') {
        document.getElementById('arrowModeBtn').classList.add('active');
      } else if (mode === 'resizeNode') {
        document.getElementById('resizeModeBtn').classList.add('active');
      }
    }

    // =========================
    // Nodi
    // =========================
    function createNodeElement(type, x, y, content) {
      const nodeEl = document.createElement('div');
      nodeEl.classList.add('node');
      const id = generateId();
      nodeEl.dataset.id = id;
      nodeEl.style.left = x + 'px';
      nodeEl.style.top = y + 'px';

      if (type === 'text') {
        nodeEl.classList.add('text-node');
        const contentEl = document.createElement('div');
        contentEl.classList.add('node-content');
        contentEl.contentEditable = true;
        contentEl.textContent = content || 'Testo';
        contentEl.style.whiteSpace = 'pre-wrap'; // default a capo
        nodeEl.appendChild(contentEl);
        // Applica stile corrente al nuovo nodo
        const nodeObjTemp = { type: 'text', el: nodeEl };
        applyTextFormattingToNode(nodeObjTemp);
      } else if (type === 'image') {
        nodeEl.classList.add('image-node');
        const img = document.createElement('img');
        img.src = content;
        nodeEl.appendChild(img);
      }

      nodeZCounter++;
      nodeEl.style.zIndex = nodeZCounter;

      workspace.appendChild(nodeEl);

      const nodeObj = {
        id,
        el: nodeEl,
        type,
        x,
        y,
        z: nodeZCounter
      };
      nodes.push(nodeObj);

      selectNode(nodeObj.id);
      updateResizeHandles();
      redrawCanvas();
      syncControlsFromSelected();
    }

    function addTextNode(forceWordArt = false) {
      const input = document.getElementById('textInput');
      const raw = (input.value || '').replace(/\r/g,'');
      const text = raw.trim() || 'Testo';
      if (forceWordArt && textStyle.wordArt === 'none') textStyle.wordArt = 'outline';
      createNodeElement('text', 50, 50, text);
      input.value = '';
      input.style.height = 'auto';
    }

    function addImageNode(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const src = e.target.result;
        createNodeElement('image', 80, 80, src);
      };
      reader.readAsDataURL(file);
    }

    // =========================
    // Selezione
    // =========================
    function clearSelection() {
      selectedNodeId = null;
      selectedConnectorId = null;
      selectedFreeArrowId = null;
      connectorStartNodeId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
      syncControlsFromSelected();
    }

    function selectNode(id) {
      selectedNodeId = id;
      selectedConnectorId = null;
      selectedFreeArrowId = null;

      nodes.forEach(n => {
        if (n.id === id) n.el.classList.add('selected');
        else n.el.classList.remove('selected');
      });

      updateResizeHandles();
      redrawCanvas();
      syncControlsFromSelected();
    }

    function selectConnector(id) {
      selectedConnectorId = id;
      selectedNodeId = null;
      selectedFreeArrowId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
      syncControlsFromSelected();
    }

    function selectFreeArrow(id) {
      selectedFreeArrowId = id;
      selectedNodeId = null;
      selectedConnectorId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
      syncControlsFromSelected();
    }

    function getNodeById(id) {
      return nodes.find(n => n.id === id);
    }

    // =========================
    // Ridimensionamento nodi
    // =========================
    function updateResizeHandles() {
      document.querySelectorAll('.resize-handle').forEach(h => h.remove());

      if (mode !== 'resizeNode' || !selectedNodeId) return;

      const node = getNodeById(selectedNodeId);
      if (!node) return;

      ['tl','tr','bl','br'].forEach(corner => {
        const handle = document.createElement('div');
        handle.classList.add('resize-handle', corner);
        handle.dataset.corner = corner;
        handle.addEventListener('pointerdown', onResizeHandleDown);
        node.el.appendChild(handle);
      });
    }

    function onResizeHandleDown(e) {
      e.stopPropagation();
      e.preventDefault();

      if (mode !== 'resizeNode') return;

      const handle = e.currentTarget;
      const corner = handle.dataset.corner;
      const node = getNodeById(selectedNodeId);
      if (!node) return;

      const rectWorkspace = workspace.getBoundingClientRect();
      const rect = node.el.getBoundingClientRect();

      resizingNode = node;
      resizeCorner = corner;
      resizeStart = {
        pointerId: e.pointerId,
        x: e.clientX - rectWorkspace.left,
        y: e.clientY - rectWorkspace.top,
        left: rect.left - rectWorkspace.left,
        top: rect.top - rectWorkspace.top,
        width: rect.width,
        height: rect.height
      };

      workspace.setPointerCapture(e.pointerId);
      workspace.addEventListener('pointermove', onResizePointerMove);
      workspace.addEventListener('pointerup', onResizePointerUp);
      workspace.addEventListener('pointercancel', onResizePointerUp);
    }

    function onResizePointerMove(e) {
      if (!resizingNode || !resizeStart || e.pointerId !== resizeStart.pointerId) return;

      const rectWorkspace = workspace.getBoundingClientRect();
      const x = e.clientX - rectWorkspace.left;
      const y = e.clientY - rectWorkspace.top;

      const dx = x - resizeStart.x;
      const dy = y - resizeStart.y;

      let newLeft = resizeStart.left;
      let newTop = resizeStart.top;
      let newWidth = resizeStart.width;
      let newHeight = resizeStart.height;

      if (resizeCorner === 'br') {
        newWidth = Math.max(40, resizeStart.width + dx);
        newHeight = Math.max(30, resizeStart.height + dy);
      } else if (resizeCorner === 'bl') {
        newWidth = Math.max(40, resizeStart.width - dx);
        newHeight = Math.max(30, resizeStart.height + dy);
        newLeft = resizeStart.left + dx;
      } else if (resizeCorner === 'tr') {
        newWidth = Math.max(40, resizeStart.width + dx);
        newHeight = Math.max(30, resizeStart.height - dy);
        newTop = resizeStart.top + dy;
      } else if (resizeCorner === 'tl') {
        newWidth = Math.max(40, resizeStart.width - dx);
        newHeight = Math.max(30, resizeStart.height - dy);
        newLeft = resizeStart.left + dx;
        newTop = resizeStart.top + dy;
      }

      resizingNode.el.style.left = newLeft + 'px';
      resizingNode.el.style.top = newTop + 'px';
      resizingNode.el.style.width = newWidth + 'px';
      resizingNode.el.style.height = newHeight + 'px';

      resizingNode.x = newLeft;
      resizingNode.y = newTop;

      redrawCanvas();
    }

    function onResizePointerUp(e) {
      if (!resizeStart || e.pointerId !== resizeStart.pointerId) return;

      workspace.releasePointerCapture(e.pointerId);
      workspace.removeEventListener('pointermove', onResizePointerMove);
      workspace.removeEventListener('pointerup', onResizePointerUp);
      workspace.removeEventListener('pointercancel', onResizePointerUp);

      resizingNode = null;
      resizeCorner = null;
      resizeStart = null;
    }

    // =========================
    // Sposta / trascina nodi
    // =========================
    function getTopmostNodeAt(x, y) {
      let best = null;
      let bestZ = -Infinity;
      nodes.forEach(n => {
        const rect = n.el.getBoundingClientRect();
        const wsRect = workspace.getBoundingClientRect();
        const left = (rect.left - wsRect.left) + workspaceWrapper.scrollLeft;
        const top = (rect.top - wsRect.top) + workspaceWrapper.scrollTop;
        const right = left + rect.width;
        const bottom = top + rect.height;
        if (x >= left && x <= right && y >= top && y <= bottom) {
          if (n.z > bestZ) {
            bestZ = n.z;
            best = n;
          }
        }
      });
      return best;
    }

    // =========================
    // Workspace pointer events
    // =========================
    workspace.addEventListener('pointerdown', onWorkspacePointerDown);

    function onWorkspacePointerDown(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = (e.clientX - wsRect.left) + workspaceWrapper.scrollLeft;
      const y = (e.clientY - wsRect.top) + workspaceWrapper.scrollTop;

      // ModalitÃ  PAN: trascina la lavagna (non i nodi)
      if (mode === 'pan') {
        e.preventDefault();
        panning = true;
        panPointerId = e.pointerId;
        workspace.setPointerCapture(e.pointerId);
        workspace.style.cursor = 'grabbing';
        panStartX = e.clientX;
        panStartY = e.clientY;
        panStartScrollLeft = workspaceWrapper.scrollLeft;
        panStartScrollTop = workspaceWrapper.scrollTop;
        return;
      }

      // ModalitÃ  freccia libera
      if (mode === 'arrow') {
        e.preventDefault();

        // 1) prova a selezionare freccia esistente
        const hitArrow = findNearestArrow(x, y, 8);
        if (hitArrow) {
          selectFreeArrow(hitArrow.id);
          draggingFreeArrowId = hitArrow.id;
          dragArrowPointerId = e.pointerId;
          dragArrowStart = { pointerX: x, pointerY: y, cx: hitArrow.cx, cy: hitArrow.cy };
          return;
        }

        // 2) disegno freccia nuova (tap-tap)
        if (!drawingArrowStart) {
          drawingArrowStart = { x, y };
        } else {
          const dx = x - drawingArrowStart.x;
          const dy = y - drawingArrowStart.y;
          const length = Math.max(30, Math.sqrt(dx*dx + dy*dy));
          const angle = Math.atan2(dy, dx);
          const cx = (drawingArrowStart.x + x) / 2;
          const cy = (drawingArrowStart.y + y) / 2;
          canvasZCounter++;
          const arrow = {
            id: generateId(),
            cx,
            cy,
            length,
            angle,
            color: currentArrowColor,
            z: canvasZCounter
          };
          freeArrows.push(arrow);
          drawingArrowStart = null;
          selectFreeArrow(arrow.id);
          redrawCanvas();
        }
        return;
      }

      // ModalitÃ  connettore nodi
      if (mode === 'connector') {
        e.preventDefault();
        const node = getTopmostNodeAt(x, y);
        if (node) {
          handleConnectorClick(node.id);
        }
        return;
      }

      // ModalitÃ  ridimensiona: il drag Ã¨ gestito dalle maniglie, non da qui
      if (mode === 'resizeNode') {
        const node = getTopmostNodeAt(x, y);
        if (node) {
          selectNode(node.id);
        } else {
          clearSelection();
        }
        return;
      }

      // ModalitÃ  normale: selezione e drag nodi, selezione frecce/connettori
      if (mode === 'normal') {
        const node = getTopmostNodeAt(x, y);

        if (node) {
          const targetContent = e.target.closest('.node-content');
          if (node.type === 'text' && targetContent && e.detail === 2) {
            targetContent.focus();
            return;
          }

          e.preventDefault();
          selectNode(node.id);

          draggingNode = node;
          dragNodePointerId = e.pointerId;
          const rect = node.el.getBoundingClientRect();
          dragOffsetX = x - ((rect.left - wsRect.left) + workspaceWrapper.scrollLeft);
          dragOffsetY = y - ((rect.top - wsRect.top) + workspaceWrapper.scrollTop);
          return;
        }

        const hit = findNearestConnectorOrArrow(x, y, 8);
        if (hit && hit.type === 'connector') {
          selectConnector(hit.obj.id);
        } else if (hit && hit.type === 'arrow') {
          selectFreeArrow(hit.obj.id);
        } else {
          clearSelection();
        }
      }
    }

    function onWorkspacePointerMove(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = (e.clientX - wsRect.left) + workspaceWrapper.scrollLeft;
      const y = (e.clientY - wsRect.top) + workspaceWrapper.scrollTop;

      if (panning && e.pointerId === panPointerId) {
        e.preventDefault();
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        workspaceWrapper.scrollLeft = panStartScrollLeft - dx;
        workspaceWrapper.scrollTop = panStartScrollTop - dy;
        maybeGrowWorkspace();
        return;
      }

      if (mode === 'normal' && draggingNode && e.pointerId === dragNodePointerId) {
        e.preventDefault();
        const newX = x - dragOffsetX;
        const newY = y - dragOffsetY;
        draggingNode.x = newX;
        draggingNode.y = newY;
        draggingNode.el.style.left = newX + 'px';
        draggingNode.el.style.top = newY + 'px';
        redrawCanvas();
        maybeGrowWorkspace();
      }

      if (mode === 'arrow' && draggingFreeArrowId && e.pointerId === dragArrowPointerId) {
        e.preventDefault();
        const arrow = freeArrows.find(a => a.id === draggingFreeArrowId);
        if (!arrow) return;

        const dx = x - dragArrowStart.pointerX;
        const dy = y - dragArrowStart.pointerY;
        arrow.cx = dragArrowStart.cx + dx;
        arrow.cy = dragArrowStart.cy + dy;
        redrawCanvas();
        maybeGrowWorkspace();
      }
    }

    function onWorkspacePointerUp(e) {
      if (panning && e.pointerId === panPointerId) {
        panning = false;
        panPointerId = null;
        try { workspace.releasePointerCapture(e.pointerId); } catch(_) {}
        workspace.style.cursor = 'grab';
        maybeGrowWorkspace();
      }

      if (draggingNode && e.pointerId === dragNodePointerId) {
        draggingNode = null;
        dragNodePointerId = null;
      }

      if (draggingFreeArrowId && e.pointerId === dragArrowPointerId) {
        draggingFreeArrowId = null;
        dragArrowPointerId = null;
      }
    }

    workspace.addEventListener('pointermove', onWorkspacePointerMove);
    workspace.addEventListener('pointerup', onWorkspacePointerUp);
    workspace.addEventListener('pointercancel', onWorkspacePointerUp);

    // =========================
    // Connettori tra nodi
    // =========================
    function handleConnectorClick(nodeId) {
      if (connectorStartNodeId == null) {
        connectorStartNodeId = nodeId;
        selectNode(nodeId);
      } else {
        const fromId = connectorStartNodeId;
        const toId = nodeId;
        if (fromId !== toId) {
          canvasZCounter++;
          const conn = {
            id: generateId(),
            fromId,
            toId,
            color: currentArrowColor,
            z: canvasZCounter
          };
          connectors.push(conn);
        }
        connectorStartNodeId = null;
        setMode('normal'); // one-shot
        clearSelection();
        redrawCanvas();
        maybeGrowWorkspace();
      }
    }

    function findNearestConnectorOrArrow(x, y, maxDist) {
      let best = null;
      let bestDist = maxDist;

      connectors.forEach(conn => {
        const n1 = getNodeById(conn.fromId);
        const n2 = getNodeById(conn.toId);
        if (!n1 || !n2) return;

        const p1 = getNodeCenter(n1);
        const p2 = getNodeCenter(n2);

        const d = pointToSegmentDistance(x, y, p1.x, p1.y, p2.x, p2.y);
        if (d < bestDist) {
          bestDist = d;
          best = { type: 'connector', obj: conn };
        }
      });

      freeArrows.forEach(a => {
        const p1x = a.cx - Math.cos(a.angle) * a.length / 2;
        const p1y = a.cy - Math.sin(a.angle) * a.length / 2;
        const p2x = a.cx + Math.cos(a.angle) * a.length / 2;
        const p2y = a.cy + Math.sin(a.angle) * a.length / 2;
        const d = pointToSegmentDistance(x, y, p1x, p1y, p2x, p2y);
        if (d < bestDist) {
          bestDist = d;
          best = { type: 'arrow', obj: a };
        }
      });

      return best;
    }

    function getNodeCenter(node) {
      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      const cx = rect.left - wsRect.left + rect.width / 2;
      const cy = rect.top - wsRect.top + rect.height / 2;
      return { x: cx, y: cy };
    }

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) {
        const ddx = px - x1;
        const ddy = py - y1;
        return Math.sqrt(ddx*ddx + ddy*ddy);
      }
      const t = ((px - x1)*dx + (py - y1)*dy) / (dx*dx + dy*dy);
      const tClamped = Math.max(0, Math.min(1, t));
      const projX = x1 + tClamped * dx;
      const projY = y1 + tClamped * dy;
      const ddx = px - projX;
      const ddy = py - projY;
      return Math.sqrt(ddx*ddx + ddy*ddy);
    }

    // =========================
    // Frecce libere
    // =========================
    function findNearestArrow(x, y, maxDist) {
      let bestArrow = null;
      let bestDist = maxDist;

      freeArrows.forEach(a => {
        const p1x = a.cx - Math.cos(a.angle) * a.length / 2;
        const p1y = a.cy - Math.sin(a.angle) * a.length / 2;
        const p2x = a.cx + Math.cos(a.angle) * a.length / 2;
        const p2y = a.cy + Math.sin(a.angle) * a.length / 2;
        const d = pointToSegmentDistance(x, y, p1x, p1y, p2x, p2y);
        if (d < bestDist) {
          bestDist = d;
          bestArrow = a;
        }
      });

      return bestArrow;
    }

    function adjustArrowLength(delta) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      arrow.length = Math.max(20, arrow.length + delta);
      redrawCanvas();
    }

    function rotateArrow(deltaDeg) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      const rad = deltaDeg * Math.PI / 180;
      arrow.angle += rad;
      redrawCanvas();
    }

    // =========================
    // Colori
    // =========================
    function applyBorderColor(color) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node) return;
      node.el.style.borderColor = color;
    }

    function applyTextColor(color) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;
      contentEl.style.color = color;
    }

    function applyArrowColor(color) {
      currentArrowColor = color;
      if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (conn) conn.color = color;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (arrow) arrow.color = color;
      }
      redrawCanvas();
    }

    // =========================
    // Livelli (z-index)
    // =========================
    function bringToFront() {
      if (!selectedNodeId && !selectedConnectorId && !selectedFreeArrowId) return;

      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        nodeZCounter++;
        node.z = nodeZCounter;
        node.el.style.zIndex = nodeZCounter;
      } else if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (!conn) return;
        canvasZCounter++;
        conn.z = canvasZCounter;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (!arrow) return;
        canvasZCounter++;
        arrow.z = canvasZCounter;
      }

      redrawCanvas();
    }

    function sendToBack() {
      if (!selectedNodeId && !selectedConnectorId && !selectedFreeArrowId) return;

      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        let minZ = Infinity;
        nodes.forEach(n => { if (n.z < minZ) minZ = n.z; });
        node.z = minZ - 1;
        node.el.style.zIndex = node.z;
      } else if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (!conn) return;
        let minZ = Infinity;
        connectors.forEach(c => { if (c.z < minZ) minZ = c.z; });
        freeArrows.forEach(a => { if (a.z < minZ) minZ = a.z; });
        conn.z = minZ - 1;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (!arrow) return;
        let minZ = Infinity;
        connectors.forEach(c => { if (c.z < minZ) minZ = c.z; });
        freeArrows.forEach(a => { if (a.z < minZ) minZ = a.z; });
        arrow.z = minZ - 1;
      }

      redrawCanvas();
    }

    // =========================
    // Delete
    // =========================
    function deleteSelected() {
      if (selectedNodeId) {
        const nodeId = selectedNodeId;
        const node = getNodeById(nodeId);
        if (node) {
          node.el.remove();
        }
        nodes = nodes.filter(n => n.id !== nodeId);
        connectors = connectors.filter(c => c.fromId !== nodeId && c.toId !== nodeId);
        selectedNodeId = null;
      } else if (selectedConnectorId) {
        connectors = connectors.filter(c => c.id !== selectedConnectorId);
        selectedConnectorId = null;
      } else if (selectedFreeArrowId) {
        freeArrows = freeArrows.filter(a => a.id !== selectedFreeArrowId);
        selectedFreeArrowId = null;
      }
      clearSelection();
      redrawCanvas();
    }

    function clearAll() {
      nodes.forEach(n => n.el.remove());
      nodes = [];
      connectors = [];
      freeArrows = [];
      clearSelection();
      redrawCanvas();
    }

    // =========================
    // Disegno canvas
    // =========================
    function drawArrow(x1, y1, x2, y2, color, isSelected) {
      const headLength = 10;
      const dx = x2 - x1;
      const dy = y2 - y1;
      const angle = Math.atan2(dy, dx);

      ctx.save();
      ctx.lineWidth = isSelected ? 3 : 2;
      ctx.strokeStyle = color || '#000';
      ctx.fillStyle = color || '#000';

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(x2 - headLength * Math.cos(angle - Math.PI / 6),
                 y2 - headLength * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(x2 - headLength * Math.cos(angle + Math.PI / 6),
                 y2 - headLength * Math.sin(angle + Math.PI / 6));
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function redrawCanvas() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const connectorsSorted = [...connectors].sort((a,b) => a.z - b.z);
      const arrowsSorted = [...freeArrows].sort((a,b) => a.z - b.z);

      connectorsSorted.forEach(conn => {
        const n1 = getNodeById(conn.fromId);
        const n2 = getNodeById(conn.toId);
        if (!n1 || !n2) return;
        const c1 = getNodeCenter(n1);
        const c2 = getNodeCenter(n2);
        const isSelected = (conn.id === selectedConnectorId);
        drawArrow(c1.x, c1.y, c2.x, c2.y, conn.color, isSelected);
      });

      arrowsSorted.forEach(a => {
        const x1 = a.cx - Math.cos(a.angle) * a.length / 2;
        const y1 = a.cy - Math.sin(a.angle) * a.length / 2;
        const x2 = a.cx + Math.cos(a.angle) * a.length / 2;
        const y2 = a.cy + Math.sin(a.angle) * a.length / 2;
        const isSelected = (a.id === selectedFreeArrowId);
        drawArrow(x1,y1,x2,y2, a.color, isSelected);
      });
    }

    // =========================
    // Export PNG / PDF
    // =========================
    async function saveAsPng(scale = 1, filenameSuffix = '') {
      const canvasExport = await html2canvas(workspace, { scale });
      const link = document.createElement('a');
      link.href = canvasExport.toDataURL('image/png');
      link.download = 'mindweave-lavagna' + filenameSuffix + '.png';
      link.click();
    }

    async function saveAsPdf() {
      const canvasExport = await html2canvas(workspace);
      const imgData = canvasExport.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('l', 'pt', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const ratio = Math.min(pageWidth / canvasExport.width, pageHeight / canvasExport.height);
      const imgWidth = canvasExport.width * ratio;
      const imgHeight = canvasExport.height * ratio;
      const x = (pageWidth - imgWidth) / 2;
      const y = (pageHeight - imgHeight) / 2;
      pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
      pdf.save('mindweave-lavagna.pdf');
    }

    // =========================
    // Salva / Carica stato lavagna (formato MindWeave JSON)
    // =========================
    function exportBoardState() {
      const wsRect = workspace.getBoundingClientRect();

      const state = {
        nodes: nodes.map(n => {
          const rect = n.el.getBoundingClientRect();
          const left = rect.left - wsRect.left;
          const top = rect.top - wsRect.top;
          const width = rect.width;
          const height = rect.height;

          const base = {
            id: n.id,
            type: n.type,
            x: left,
            y: top,
            z: n.z,
            width,
            height,
            borderColor: n.el.style.borderColor || '#666666'
          };

          if (n.type === 'text') {
            const contentEl = n.el.querySelector('.node-content');
            const cs = window.getComputedStyle(contentEl);
            base.text = contentEl.textContent || '';
            base.textColor = cs.color;
            base.fontSize = cs.fontSize;
            base.fontFamily = cs.fontFamily;
            base.fontWeight = cs.fontWeight;
            base.fontStyle = cs.fontStyle;
            base.textDecoration = cs.textDecorationLine;
            base.textTransform = cs.textTransform;
            base.textAlign = cs.textAlign;
            base.whiteSpace = cs.whiteSpace;
            base.wordArt = n.el.dataset.wordart || 'none';
          } else if (n.type === 'image') {
            const img = n.el.querySelector('img');
            base.src = img ? img.src : '';
          }

          return base;
        }),
        connectors: connectors.map(c => ({
          id: c.id,
          fromId: c.fromId,
          toId: c.toId,
          color: c.color,
          z: c.z
        })),
        freeArrows: freeArrows.map(a => ({
          id: a.id,
          cx: a.cx,
          cy: a.cy,
          length: a.length,
          angle: a.angle,
          color: a.color,
          z: a.z
        })),
        nextId,
        nodeZCounter,
        canvasZCounter
      };

      return state;
    }

    function downloadBoardState() {
      const state = exportBoardState();
      const json = JSON.stringify(state, null, 2);
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'mindweave-lavagna.json';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function loadBoardStateFromObject(state) {
      clearAll();

      nodes = [];
      connectors = [];
      freeArrows = [];

      (state.nodes || []).forEach(sn => {
        const nodeEl = document.createElement('div');
        nodeEl.classList.add('node');
        if (sn.type === 'text') nodeEl.classList.add('text-node');
        if (sn.type === 'image') nodeEl.classList.add('image-node');

        nodeEl.dataset.id = sn.id;
        nodeEl.style.position = 'absolute';
        nodeEl.style.left = (sn.x || 0) + 'px';
        nodeEl.style.top = (sn.y || 0) + 'px';
        if (sn.width) nodeEl.style.width = sn.width + 'px';
        if (sn.height) nodeEl.style.height = sn.height + 'px';
        nodeEl.style.zIndex = sn.z || 10;
        if (sn.borderColor) nodeEl.style.borderColor = sn.borderColor;

        if (sn.type === 'text') {
          const contentEl = document.createElement('div');
          contentEl.classList.add('node-content');
          contentEl.contentEditable = true;
          contentEl.textContent = sn.text || '';
          contentEl.style.textAlign = 'center';
          if (sn.textColor) contentEl.style.color = sn.textColor;
          if (sn.fontSize) contentEl.style.fontSize = sn.fontSize;
          if (sn.fontFamily) contentEl.style.fontFamily = sn.fontFamily;
          if (sn.fontWeight) contentEl.style.fontWeight = sn.fontWeight;
          if (sn.fontStyle) contentEl.style.fontStyle = sn.fontStyle;
          if (sn.textDecoration) contentEl.style.textDecoration = sn.textDecoration;
          if (sn.textTransform) contentEl.style.textTransform = sn.textTransform;
          if (sn.textAlign) contentEl.style.textAlign = sn.textAlign;
          if (sn.whiteSpace) contentEl.style.whiteSpace = sn.whiteSpace;
          nodeEl.dataset.wordart = sn.wordArt || 'none';
          // re-applica classi WordArt
          contentEl.classList.remove('wordart','wordart-outline','wordart-shadow','wordart-neon','wordart-gradient');
          if ((sn.wordArt || 'none') !== 'none') {
            contentEl.classList.add('wordart');
            contentEl.classList.add('wordart-' + sn.wordArt);
          }
          nodeEl.appendChild(contentEl);
        } else if (sn.type === 'image') {
          const img = document.createElement('img');
          if (sn.src) img.src = sn.src;
          img.style.display = 'block';
          img.style.maxWidth = '100%';
          img.style.height = 'auto';
          nodeEl.appendChild(img);
        }

        workspace.appendChild(nodeEl);

        nodes.push({
          id: sn.id,
          el: nodeEl,
          type: sn.type,
          x: sn.x || 0,
          y: sn.y || 0,
          z: sn.z || 10
        });
      });

      connectors = (state.connectors || []).map(c => ({
        id: c.id,
        fromId: c.fromId,
        toId: c.toId,
        color: c.color,
        z: c.z || 1
      }));

      freeArrows = (state.freeArrows || []).map(a => ({
        id: a.id,
        cx: a.cx,
        cy: a.cy,
        length: a.length,
        angle: a.angle,
        color: a.color,
        z: a.z || 1
      }));

      let maxId = 0;
      nodes.forEach(n => { if (n.id > maxId) maxId = n.id; });
      connectors.forEach(c => { if (c.id > maxId) maxId = c.id; });
      freeArrows.forEach(a => { if (a.id > maxId) maxId = a.id; });

      nextId = state.nextId || (maxId + 1);

      let maxNodeZ = 10;
      nodes.forEach(n => { if (n.z > maxNodeZ) maxNodeZ = n.z; });
      nodeZCounter = state.nodeZCounter || maxNodeZ;

      let maxCanvasZ = 1;
      connectors.forEach(c => { if (c.z > maxCanvasZ) maxCanvasZ = c.z; });
      freeArrows.forEach(a => { if (a.z > maxCanvasZ) maxCanvasZ = a.z; });
      canvasZCounter = state.canvasZCounter || maxCanvasZ;

      clearSelection();
      redrawCanvas();
    }

    function loadBoardFromFile(file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const state = JSON.parse(e.target.result);
          loadBoardStateFromObject(state);
        } catch (err) {
          alert('File non valido (JSON corrotto o formato sconosciuto).');
          console.error(err);
        }
      };
      reader.readAsText(file, 'utf-8');
    }

    function toggleWrapSelectedText() {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;
      const current = contentEl.style.whiteSpace || window.getComputedStyle(contentEl).whiteSpace;
      if (current === 'nowrap') {
        contentEl.style.whiteSpace = 'pre-wrap';
      } else {
        contentEl.style.whiteSpace = 'nowrap';
      }
    }

    document.getElementById('addTextBtn').addEventListener('click', () => addTextNode(false));

    // Textarea: autosize + Ctrl/âŒ˜+Invio per creare nodo
    const textInputEl = document.getElementById('textInput');
    textInputEl.addEventListener('input', () => {
      textInputEl.style.height = 'auto';
      textInputEl.style.height = Math.min(90, textInputEl.scrollHeight) + 'px';
    });
    textInputEl.addEventListener('keydown', (e) => {
      const isCmd = e.metaKey || e.ctrlKey;
      if (isCmd && e.key === 'Enter') {
        e.preventDefault();
        addTextNode(false);
      }
    });
    document.getElementById('toggleWrapBtn').addEventListener('click', toggleWrapSelectedText);

    document.getElementById('addImageBtn').addEventListener('click', () => {
      const fileInput = document.getElementById('imageInput');
      const file = fileInput.files[0];
      addImageNode(file);
      fileInput.value = '';
    });

    document.getElementById('panModeBtn').addEventListener('click', () => {
      if (mode === 'pan') setMode('normal');
      else {
        // in pan non voglio connettori/resize attivi
        drawingArrowStart = null;
        connectorStartNodeId = null;
        setMode('pan');
      }
    });

    document.getElementById('resizeModeBtn').addEventListener('click', () => {
      if (mode === 'resizeNode') setMode('normal');
      else setMode('resizeNode');
    });

    document.getElementById('nodePlusBtn').addEventListener('click', () => {
      scaleSelectedNode(1.1);
    });

    document.getElementById('nodeMinusBtn').addEventListener('click', () => {
      scaleSelectedNode(0.9);
    });

    document.getElementById('connectorModeBtn').addEventListener('click', () => {
      if (mode === 'connector') setMode('normal');
      else {
        clearSelection();
        setMode('connector');
      }
    });

    document.getElementById('arrowModeBtn').addEventListener('click', () => {
      if (mode === 'arrow') {
        setMode('normal');
        drawingArrowStart = null;
      } else {
        clearSelection();
        drawingArrowStart = null;
        setMode('arrow');
      }
    });

    document.getElementById('arrowLengthPlusBtn').addEventListener('click', () => {
      adjustArrowLength(10);
    });

    document.getElementById('arrowLengthMinusBtn').addEventListener('click', () => {
      adjustArrowLength(-10);
    });

    document.getElementById('arrowRotateLeftBtn').addEventListener('click', () => {
      rotateArrow(-5);
    });

    document.getElementById('arrowRotateRightBtn').addEventListener('click', () => {
      rotateArrow(5);
    });

    document.getElementById('borderColorPicker').addEventListener('input', (e) => {
      applyBorderColor(e.target.value);
    });

    document.getElementById('textColorPicker').addEventListener('input', (e) => {
      applyTextColor(e.target.value);
    });

    document.getElementById('arrowColorPicker').addEventListener('input', (e) => {
      applyArrowColor(e.target.value);
    });

    document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);
    document.getElementById('clearAllBtn').addEventListener('click', clearAll);

    document.getElementById('savePngStandardBtn').addEventListener('click', () => {
      saveAsPng(1, '');
    });

    document.getElementById('savePngHQBtn').addEventListener('click', () => {
      saveAsPng(4, '-HQ');
    });

    document.getElementById('savePdfBtn').addEventListener('click', saveAsPdf);

    document.getElementById('saveBoardBtn').addEventListener('click', () => {
      downloadBoardState();
    });

    document.getElementById('loadBoardBtn').addEventListener('click', () => {
      const input = document.getElementById('loadBoardInput');
      input.value = '';
      input.click();
    });

    document.getElementById('loadBoardInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      loadBoardFromFile(file);
    });

    document.getElementById('bringToFrontBtn').addEventListener('click', bringToFront);
    document.getElementById('sendToBackBtn').addEventListener('click', sendToBack);

    function scaleSelectedNode(factor) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node) return;

      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      const left = rect.left - wsRect.left;
      const top = rect.top - wsRect.top;
      const newWidth = Math.max(40, rect.width * factor);
      const newHeight = Math.max(30, rect.height * factor);

      node.el.style.width = newWidth + 'px';
      node.el.style.height = newHeight + 'px';

      node.x = left;
      node.y = top;

      redrawCanvas();
    }

    setMode('normal');
  </script>
</body>
</html>
