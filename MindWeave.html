<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8" />
  <title>MindWeave â€“ Lavagna concettuale</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- Librerie per esportazione -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>

  <style>
    * {
      box-sizing: border-box;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f0f0f0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      background: #222;
      color: #fff;
      padding: 6px 10px;
      font-size: 14px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }

    header .group-label {
      font-weight: 600;
      margin-right: 4px;
    }

    button.tool-btn {
      font-size: 12px;
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #555;
      background: #333;
      color: #fff;
      cursor: pointer;
    }

    button.tool-btn.active {
      background: #ff9800;
      border-color: #ff9800;
      color: #000;
    }

    button.tool-btn:disabled {
      opacity: 0.5;
      cursor: default;
    }

    input[type="color"] {
      padding: 0;
      border: 1px solid #555;
      border-radius: 4px;
      width: 30px;
      height: 24px;
      background: transparent;
    }

    input[type="text"],
    input[type="file"] {
      font-size: 12px;
      padding: 2px 4px;
      border-radius: 4px;
      border: 1px solid #999;
      background: #fff;
    }

    #workspace-wrapper {
      flex: 1;
      padding: 6px;
      display: flex;
    }

    #workspace {
      position: relative;
      flex: 1;
      background: #ffffff;
      border-radius: 6px;
      border: 1px solid #ccc;
      overflow: hidden;
      touch-action: none;
    }

    #connectorCanvas {
      position: absolute;
      top: 0;
      left: 0;
      z-index: 5;
      pointer-events: none; /* gli eventi li gestisce il workspace */
    }

    .node {
      position: absolute;
      min-width: 80px;
      min-height: 40px;
      padding: 6px;
      border-radius: 6px;
      border: 2px solid #666;
      background: #fff;
      box-shadow: 0 2px 4px rgba(0,0,0,0.15);
      touch-action: none;
      pointer-events: auto;
    }

    .node.selected {
      border-color: red;
    }

    .node.text-node .node-content {
      width: 100%;
      min-height: 28px;
      outline: none;
      font-size: 14px;
      white-space: pre-wrap;       /* default: va a capo */
      word-wrap: break-word;
      text-align: center;          /* testo centrato nel riquadro */
      cursor: text;
      -webkit-user-select: text;   /* riabilita selezione testo */
      user-select: text;
    }

    .node.image-node img {
      display: block;
      max-width: 100%;
      height: auto;
      pointer-events: none;  /* lâ€™immagine non mangia i tocchi, li prende il nodo */
    }

    .resize-handle {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: #ff9800;
      border: 1px solid #333;
      z-index: 20;
      pointer-events: auto;
    }

    .resize-handle.tl { top: -5px; left: -5px; }
    .resize-handle.tr { top: -5px; right: -5px; }
    .resize-handle.bl { bottom: -5px; left: -5px; }
    .resize-handle.br { bottom: -5px; right: -5px; }

    #status-bar {
      font-size: 12px;
      padding: 4px 8px;
      background: #eee;
      border-top: 1px solid #ccc;
      color: #333;
    }
  </style>
</head>
<body>
  <header>
    <span class="group-label">Testo:</span>
    <input type="text" id="textInput" placeholder="Scrivi testo nodo" />
    <button class="tool-btn" id="addTextBtn">ðŸ…£+</button>
    <button class="tool-btn" id="toggleWrapBtn" title="Testo a capo ON/OFF">â†” testo</button>

    <span class="group-label">Immagine:</span>
    <input type="file" id="imageInput" accept="image/*" />
    <button class="tool-btn" id="addImageBtn">ðŸ–¼+</button>

    <span class="group-label">Nodo:</span>
    <button class="tool-btn" id="resizeModeBtn">ðŸ”³ Resize</button>
    <button class="tool-btn" id="nodePlusBtn">â–¡+</button>
    <button class="tool-btn" id="nodeMinusBtn">â–¡âˆ’</button>

    <span class="group-label">Connettori:</span>
    <button class="tool-btn" id="connectorModeBtn">â–¡â†’â–¡</button>

    <span class="group-label">Frecce:</span>
    <button class="tool-btn" id="arrowModeBtn">âžœ</button>
    <button class="tool-btn" id="arrowLengthPlusBtn">â†”+</button>
    <button class="tool-btn" id="arrowLengthMinusBtn">â†”âˆ’</button>
    <button class="tool-btn" id="arrowRotateLeftBtn">ðŸ”„âˆ’</button>
    <button class="tool-btn" id="arrowRotateRightBtn">ðŸ”„+</button>

    <span class="group-label">Colori:</span>
    <label title="Bordo nodo">ðŸ–¼</label><input type="color" id="borderColorPicker" value="#666666" />
    <label title="Testo nodo">A</label><input type="color" id="textColorPicker" value="#000000" />
    <label title="Freccia">â†’</label><input type="color" id="arrowColorPicker" value="#0000ff" />

    <span class="group-label">Livello:</span>
    <button class="tool-btn" id="bringToFrontBtn" title="Porta in primo piano">â¬† Primo</button>
    <button class="tool-btn" id="sendToBackBtn" title="Manda dietro">â¬‡ Dietro</button>

    <span class="group-label">Azioni:</span>
    <button class="tool-btn" id="deleteSelectedBtn">ðŸ—‘ Cancella</button>
    <button class="tool-btn" id="clearAllBtn">ðŸ§¹ Tutto</button>
    <button class="tool-btn" id="savePngBtn">ðŸ“¸ PNG</button>
    <button class="tool-btn" id="savePdfBtn">ðŸ“„ PDF</button>
  </header>

  <div id="workspace-wrapper">
    <div id="workspace">
      <canvas id="connectorCanvas"></canvas>
      <!-- Nodi creati dinamicamente -->
    </div>
  </div>

  <div id="status-bar">ModalitÃ : normale</div>

  <script>
    // =========================
    // Stato globale
    // =========================
    const workspace = document.getElementById('workspace');
    const canvas = document.getElementById('connectorCanvas');
    const ctx = canvas.getContext('2d');

    let mode = 'normal'; // 'normal', 'connector', 'arrow', 'resizeNode'
    let nodes = [];       // {id, el, type, x, y, z}
    let connectors = [];  // {id, fromId, toId, color, z}
    let freeArrows = [];  // {id, cx, cy, length, angle, color, z}
    let nextId = 1;

    let selectedNodeId = null;
    let selectedConnectorId = null;
    let selectedFreeArrowId = null;

    let connectorStartNodeId = null;

    let draggingNode = null;
    let dragNodePointerId = null;
    let dragOffsetX = 0;
    let dragOffsetY = 0;

    let resizingNode = null;
    let resizeCorner = null;
    let resizeStart = null; // {x,y,width,height,left,top,aspect}

    let drawingArrowStart = null; // {x,y}

    let draggingFreeArrowId = null;
    let dragArrowStart = null; // {pointerX, pointerY, cx, cy}
    let dragArrowPointerId = null;

    let currentArrowColor = document.getElementById('arrowColorPicker').value;

    const statusBar = document.getElementById('status-bar');

    // z-index per nodi (HTML) e per oggetti sul canvas (frecce + connettori)
    let nodeZCounter = 10;
    let canvasZCounter = 1;

    // =========================
    // Utility ID
    // =========================
    function generateId() {
      return nextId++;
    }

    // =========================
    // Canvas resize
    // =========================
    function resizeCanvas() {
      const rect = workspace.getBoundingClientRect();
      canvas.width = rect.width;
      canvas.height = rect.height;
      redrawCanvas();
    }

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('load', resizeCanvas);

    // =========================
    // Creazione nodi
    // =========================
    function createNodeElement(type, x, y, content) {
      const nodeEl = document.createElement('div');
      nodeEl.classList.add('node');
      const id = generateId();
      nodeEl.dataset.id = id;
      nodeEl.style.left = x + 'px';
      nodeEl.style.top = y + 'px';

      if (type === 'text') {
        nodeEl.classList.add('text-node');
        const contentEl = document.createElement('div');
        contentEl.classList.add('node-content');
        contentEl.contentEditable = true;
        contentEl.textContent = content || 'Testo';
        contentEl.style.whiteSpace = 'pre-wrap'; // default a capo
        nodeEl.appendChild(contentEl);
      } else if (type === 'image') {
        nodeEl.classList.add('image-node');
        const img = document.createElement('img');
        img.src = content;
        nodeEl.appendChild(img);
      }

      nodeZCounter++;
      nodeEl.style.zIndex = nodeZCounter;

      workspace.appendChild(nodeEl);

      const nodeObj = {
        id,
        el: nodeEl,
        type,
        x,
        y,
        z: nodeZCounter
      };
      nodes.push(nodeObj);

      selectNode(nodeObj.id);
      updateResizeHandles();
      redrawCanvas();
    }

    function addTextNode() {
      const input = document.getElementById('textInput');
      const text = input.value.trim() || 'Testo';
      createNodeElement('text', 50, 50, text);
      input.value = '';
    }

    function addImageNode(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const src = e.target.result;
        createNodeElement('image', 80, 80, src);
      };
      reader.readAsDataURL(file);
    }

    // =========================
    // Selezione
    // =========================
    function clearSelection() {
      selectedNodeId = null;
      selectedConnectorId = null;
      selectedFreeArrowId = null;
      connectorStartNodeId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    function selectNode(id) {
      selectedNodeId = id;
      selectedConnectorId = null;
      selectedFreeArrowId = null;
      nodes.forEach(n => {
        if (n.id === id) n.el.classList.add('selected');
        else n.el.classList.remove('selected');
      });
      updateResizeHandles();
      redrawCanvas();
    }

    function selectConnector(id) {
      selectedConnectorId = id;
      selectedFreeArrowId = null;
      selectedNodeId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    function selectFreeArrow(id) {
      selectedFreeArrowId = id;
      selectedConnectorId = null;
      selectedNodeId = null;
      nodes.forEach(n => n.el.classList.remove('selected'));
      updateResizeHandles();
      redrawCanvas();
    }

    // =========================
    // ModalitÃ  / UI
    // =========================
    function setMode(newMode) {
      mode = newMode;
      document.getElementById('connectorModeBtn').classList.toggle('active', mode === 'connector');
      document.getElementById('arrowModeBtn').classList.toggle('active', mode === 'arrow');
      document.getElementById('resizeModeBtn').classList.toggle('active', mode === 'resizeNode');

      let text = 'ModalitÃ : normale';
      if (mode === 'connector') text = 'ModalitÃ : connettore nodi';
      if (mode === 'arrow') text = 'ModalitÃ : freccia libera';
      if (mode === 'resizeNode') text = 'ModalitÃ : ridimensiona nodo';
      statusBar.textContent = text;

      updateResizeHandles();
    }

    // =========================
    // Hit-test nodo topmost
    // =========================
    function getTopmostNodeAt(x, y) {
      const wsRect = workspace.getBoundingClientRect();
      let candidates = [];

      nodes.forEach(n => {
        const rect = n.el.getBoundingClientRect();
        const left = rect.left - wsRect.left;
        const top = rect.top - wsRect.top;
        const right = left + rect.width;
        const bottom = top + rect.height;
        if (x >= left && x <= right && y >= top && y <= bottom) {
          candidates.push(n);
        }
      });

      if (!candidates.length) return null;

      candidates.sort((a, b) => (a.z || 0) - (b.z || 0));
      return candidates[candidates.length - 1]; // quello con z piÃ¹ alto
    }

    // =========================
    // Workspace pointer handling (UNICO punto di ingresso)
    // =========================
    workspace.addEventListener('pointerdown', onWorkspacePointerDown);
    workspace.addEventListener('pointermove', onWorkspacePointerMove);
    workspace.addEventListener('pointerup', onWorkspacePointerUp);
    workspace.addEventListener('pointercancel', onWorkspacePointerUp);

    function onWorkspacePointerDown(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;

      // ModalitÃ  freccia libera
      if (mode === 'arrow') {
        e.preventDefault();

        // 1) prova a selezionare freccia esistente
        const hitArrow = findNearestArrow(x, y, 8);
        if (hitArrow) {
          selectFreeArrow(hitArrow.id);
          draggingFreeArrowId = hitArrow.id;
          dragArrowPointerId = e.pointerId;
          dragArrowStart = { pointerX: x, pointerY: y, cx: hitArrow.cx, cy: hitArrow.cy };
          return;
        }

        // 2) disegno freccia nuova (tap-tap)
        if (!drawingArrowStart) {
          drawingArrowStart = { x, y };
        } else {
          const dx = x - drawingArrowStart.x;
          const dy = y - drawingArrowStart.y;
          const length = Math.max(30, Math.sqrt(dx*dx + dy*dy));
          const angle = Math.atan2(dy, dx);
          const cx = (drawingArrowStart.x + x) / 2;
          const cy = (drawingArrowStart.y + y) / 2;
          canvasZCounter++;
          const arrow = {
            id: generateId(),
            cx,
            cy,
            length,
            angle,
            color: currentArrowColor,
            z: canvasZCounter
          };
          freeArrows.push(arrow);
          drawingArrowStart = null;
          selectFreeArrow(arrow.id);
          redrawCanvas();
        }
        return;
      }

      // ModalitÃ  connettore nodi
      if (mode === 'connector') {
        e.preventDefault();
        const node = getTopmostNodeAt(x, y);
        if (node) {
          handleConnectorClick(node.id);
        }
        return;
      }

      // ModalitÃ  ridimensiona: il drag Ã¨ gestito dalle maniglie, non da qui
      if (mode === 'resizeNode') {
        // niente drag qui, solo eventuale selezione di nodo
        const node = getTopmostNodeAt(x, y);
        if (node) {
          selectNode(node.id);
        } else {
          clearSelection();
        }
        return;
      }

      // ModalitÃ  normale: selezione e drag nodi, selezione frecce/connettori
      if (mode === 'normal') {
        const node = getTopmostNodeAt(x, y);

        if (node) {
          // Se Ã¨ un nodo di testo e fai doppio click sulla parte di testo: entra in modifica
          const targetContent = e.target.closest('.node-content');
          if (node.type === 'text' && targetContent && e.detail === 2) {
            // doppio click per edit
            targetContent.focus();
            return;
          }

          // altrimenti: drag del nodo
          e.preventDefault();
          selectNode(node.id);

          draggingNode = node;
          dragNodePointerId = e.pointerId;
          const rect = node.el.getBoundingClientRect();
          dragOffsetX = x - (rect.left - wsRect.left);
          dragOffsetY = y - (rect.top - wsRect.top);
          return;
        }

        // nessun nodo: prova frecce / connettori
        const hit = findNearestConnectorOrArrow(x, y, 8);
        if (hit && hit.type === 'connector') {
          selectConnector(hit.obj.id);
        } else if (hit && hit.type === 'arrow') {
          selectFreeArrow(hit.obj.id);
        } else {
          clearSelection();
        }
      }
    }

    function onWorkspacePointerMove(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;

      // Drag nodo
      if (mode === 'normal' && draggingNode && e.pointerId === dragNodePointerId) {
        e.preventDefault();
        const newX = x - dragOffsetX;
        const newY = y - dragOffsetY;
        draggingNode.x = newX;
        draggingNode.y = newY;
        draggingNode.el.style.left = newX + 'px';
        draggingNode.el.style.top = newY + 'px';
        redrawCanvas();
      }

      // Drag freccia libera
      if (mode === 'arrow' && draggingFreeArrowId && e.pointerId === dragArrowPointerId) {
        e.preventDefault();
        const arrow = freeArrows.find(a => a.id === draggingFreeArrowId);
        if (!arrow) return;
        const dx = x - dragArrowStart.pointerX;
        const dy = y - dragArrowStart.pointerY;
        arrow.cx = dragArrowStart.cx + dx;
        arrow.cy = dragArrowStart.cy + dy;
        redrawCanvas();
      }
    }

    function onWorkspacePointerUp(e) {
      if (draggingNode && e.pointerId === dragNodePointerId) {
        draggingNode = null;
        dragNodePointerId = null;
      }
      if (draggingFreeArrowId && e.pointerId === dragArrowPointerId) {
        draggingFreeArrowId = null;
        dragArrowPointerId = null;
        dragArrowStart = null;
      }
    }

    // =========================
    // Connettori nodi
    // =========================
    function handleConnectorClick(nodeId) {
      if (connectorStartNodeId == null) {
        connectorStartNodeId = nodeId;
        selectNode(nodeId);
      } else {
        const fromId = connectorStartNodeId;
        const toId = nodeId;
        if (fromId !== toId) {
          canvasZCounter++;
          const conn = {
            id: generateId(),
            fromId,
            toId,
            color: currentArrowColor,
            z: canvasZCounter
          };
          connectors.push(conn);
        }
        connectorStartNodeId = null;
        setMode('normal'); // one-shot
        clearSelection();
      }
      redrawCanvas();
    }

    // =========================
    // Geometria frecce
    // =========================
    function distancePointToSegment(px, py, x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      if (dx === 0 && dy === 0) {
        return Math.hypot(px - x1, py - y1);
      }
      const t = ((px - x1) * dx + (py - y1) * dy) / (dx*dx + dy*dy);
      const clamped = Math.max(0, Math.min(1, t));
      const projX = x1 + clamped * dx;
      const projY = y1 + clamped * dy;
      return Math.hypot(px - projX, py - projY);
    }

    function getArrowEndpoints(arrow) {
      const half = arrow.length / 2;
      const dx = Math.cos(arrow.angle) * half;
      const dy = Math.sin(arrow.angle) * half;
      return {
        x1: arrow.cx - dx,
        y1: arrow.cy - dy,
        x2: arrow.cx + dx,
        y2: arrow.cy + dy
      };
    }

    function findNearestArrow(x, y, threshold) {
      let best = null;
      let bestDist = Infinity;
      freeArrows.forEach(a => {
        const {x1,y1,x2,y2} = getArrowEndpoints(a);
        const d = distancePointToSegment(x,y,x1,y1,x2,y2);
        if (d < threshold && d < bestDist) {
          bestDist = d;
          best = a;
        }
      });
      return best;
    }

    function findNearestConnectorOrArrow(x, y, threshold) {
      let best = null;
      let bestDist = Infinity;

      // connettori
      connectors.forEach(c => {
        const fromNode = getNodeById(c.fromId);
        const toNode = getNodeById(c.toId);
        if (!fromNode || !toNode) return;
        const p1 = getNodeCenter(fromNode);
        const p2 = getNodeCenter(toNode);
        const d = distancePointToSegment(x,y,p1.x,p1.y,p2.x,p2.y);
        if (d < threshold && d < bestDist) {
          bestDist = d;
          best = {type: 'connector', obj: c};
        }
      });

      // frecce libere
      freeArrows.forEach(a => {
        const {x1,y1,x2,y2} = getArrowEndpoints(a);
        const d = distancePointToSegment(x,y,x1,y1,x2,y2);
        if (d < threshold && d < bestDist) {
          bestDist = d;
          best = {type: 'arrow', obj: a};
        }
      });

      return best;
    }

    // =========================
    // Calcolo centri nodi
    // =========================
    function getNodeById(id) {
      return nodes.find(n => n.id === id) || null;
    }

    function getNodeCenter(node) {
      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      return {
        x: (rect.left - wsRect.left) + rect.width / 2,
        y: (rect.top - wsRect.top) + rect.height / 2
      };
    }

    // =========================
    // Ridimensionamento nodi
    // =========================
    function updateResizeHandles() {
      document.querySelectorAll('.resize-handle').forEach(h => h.remove());

      if (mode !== 'resizeNode' || !selectedNodeId) return;

      const node = getNodeById(selectedNodeId);
      if (!node) return;

      ['tl','tr','bl','br'].forEach(corner => {
        const handle = document.createElement('div');
        handle.classList.add('resize-handle', corner);
        handle.dataset.corner = corner;
        handle.addEventListener('pointerdown', onResizeHandleDown);
        node.el.appendChild(handle);
      });
    }

    function onResizeHandleDown(e) {
      e.preventDefault();
      e.stopPropagation();
      const handle = e.currentTarget;
      const corner = handle.dataset.corner;
      const node = getNodeById(selectedNodeId);
      if (!node) return;

      resizingNode = node;
      resizeCorner = corner;

      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      const left = rect.left - wsRect.left;
      const top = rect.top - wsRect.top;
      const width = rect.width;
      const height = rect.height;
      const aspect = height / width;

      const pointerX = e.clientX - wsRect.left;
      const pointerY = e.clientY - wsRect.top;

      resizeStart = { pointerX, pointerY, left, top, width, height, aspect };

      workspace.setPointerCapture(e.pointerId);
      // useremo onWorkspacePointerMove / Up per aggiornare, ma memorizziamo che stiamo ridimensionando
    }

    // Adattiamo onWorkspacePointerMove / Up per gestire anche il resize
    const _oldWorkspacePointerMove = onWorkspacePointerMove;
    const _oldWorkspacePointerUp = onWorkspacePointerUp;

    // (ridefiniamo per includere il resize mantenendo il resto)
    workspace.removeEventListener('pointermove', onWorkspacePointerMove);
    workspace.removeEventListener('pointerup', onWorkspacePointerUp);
    workspace.removeEventListener('pointercancel', onWorkspacePointerUp);

    workspace.addEventListener('pointermove', function(e) {
      const wsRect = workspace.getBoundingClientRect();
      const x = e.clientX - wsRect.left;
      const y = e.clientY - wsRect.top;

      // Resize attivo?
      if (resizingNode && resizeStart) {
        e.preventDefault();
        let dx = x - resizeStart.pointerX;
        let dy = y - resizeStart.pointerY;

        let newLeft = resizeStart.left;
        let newTop = resizeStart.top;
        let newWidth = resizeStart.width;
        let newHeight = resizeStart.height;

        if (resizeCorner === 'br') {
          newWidth = resizeStart.width + dx;
          newHeight = resizeStart.height + dy;
        } else if (resizeCorner === 'bl') {
          newWidth = resizeStart.width - dx;
          newHeight = resizeStart.height + dy;
          newLeft = resizeStart.left + dx;
        } else if (resizeCorner === 'tr') {
          newWidth = resizeStart.width + dx;
          newHeight = resizeStart.height - dy;
          newTop = resizeStart.top + dy;
        } else if (resizeCorner === 'tl') {
          newWidth = resizeStart.width - dx;
          newHeight = resizeStart.height - dy;
          newLeft = resizeStart.left + dx;
          newTop = resizeStart.top + dy;
        }

        newWidth = Math.max(60, newWidth);
        newHeight = Math.max(40, newHeight);

        if (resizingNode.type === 'image') {
          newHeight = newWidth * resizeStart.aspect;
        }

        resizingNode.el.style.left = newLeft + 'px';
        resizingNode.el.style.top = newTop + 'px';
        resizingNode.el.style.width = newWidth + 'px';
        resizingNode.el.style.height = newHeight + 'px';

        resizingNode.x = newLeft;
        resizingNode.y = newTop;

        redrawCanvas();
        return;
      }

      // altrimenti, comportati come prima
      _oldWorkspacePointerMove(e);
    });

    workspace.addEventListener('pointerup', function(e) {
      if (resizingNode) {
        resizingNode = null;
        resizeCorner = null;
        resizeStart = null;
        workspace.releasePointerCapture(e.pointerId);
      }
      _oldWorkspacePointerUp(e);
    });

    workspace.addEventListener('pointercancel', function(e) {
      if (resizingNode) {
        resizingNode = null;
        resizeCorner = null;
        resizeStart = null;
      }
      _oldWorkspacePointerUp(e);
    });

    // Nodo + / Nodo - (nodo + font per testi)
    function scaleSelectedNode(factor) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node) return;
      const rect = node.el.getBoundingClientRect();
      const wsRect = workspace.getBoundingClientRect();
      const width = rect.width * factor;
      const height = rect.height * factor;
      const centerX = (rect.left - wsRect.left) + rect.width / 2;
      const centerY = (rect.top - wsRect.top) + rect.height / 2;

      const newWidth = Math.max(60, width);
      const newHeight = Math.max(40, height);

      const newLeft = centerX - newWidth / 2;
      const newTop = centerY - newHeight / 2;

      node.el.style.width = newWidth + 'px';
      node.el.style.height = newHeight + 'px';
      node.el.style.left = newLeft + 'px';
      node.el.style.top = newTop + 'px';

      node.x = newLeft;
      node.y = newTop;

      if (node.type === 'text') {
        const contentEl = node.el.querySelector('.node-content');
        if (contentEl) {
          const cs = window.getComputedStyle(contentEl);
          const currentSize = parseFloat(cs.fontSize) || 14;
          let newSize = currentSize * factor;
          newSize = Math.max(8, Math.min(72, newSize));
          contentEl.style.fontSize = newSize + 'px';
        }
      }

      redrawCanvas();
    }

    // =========================
    // Colori
    // =========================
    function applyBorderColor(color) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node) return;
      node.el.style.borderColor = color;
    }

    function applyTextColor(color) {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (contentEl) contentEl.style.color = color;
    }

    function applyArrowColor(color) {
      currentArrowColor = color;
      if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (conn) conn.color = color;
      }
      if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (arrow) arrow.color = color;
      }
      redrawCanvas();
    }

    function toggleWrapSelectedText() {
      if (!selectedNodeId) return;
      const node = getNodeById(selectedNodeId);
      if (!node || node.type !== 'text') return;
      const contentEl = node.el.querySelector('.node-content');
      if (!contentEl) return;
      const current = contentEl.style.whiteSpace || window.getComputedStyle(contentEl).whiteSpace;
      if (current === 'nowrap') {
        contentEl.style.whiteSpace = 'pre-wrap';
      } else {
        contentEl.style.whiteSpace = 'nowrap';
      }
    }

    // =========================
    // Frecce: allunga / accorcia / ruota
    // =========================
    function adjustArrowLength(delta) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      arrow.length = Math.max(30, arrow.length + delta);
      redrawCanvas();
    }

    function rotateArrow(deltaDeg) {
      if (!selectedFreeArrowId) return;
      const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
      if (!arrow) return;
      const deltaRad = deltaDeg * Math.PI / 180;
      arrow.angle += deltaRad;
      redrawCanvas();
    }

    // =========================
    // Livelli (primo piano / dietro)
    // =========================
    function bringToFront() {
      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        nodeZCounter++;
        node.z = nodeZCounter;
        node.el.style.zIndex = node.z;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (!arrow) return;
        canvasZCounter++;
        arrow.z = canvasZCounter;
      } else if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (!conn) return;
        canvasZCounter++;
        conn.z = canvasZCounter;
      }
      redrawCanvas();
    }

    function sendToBack() {
      if (selectedNodeId) {
        const node = getNodeById(selectedNodeId);
        if (!node) return;
        node.z = 1;
        node.el.style.zIndex = node.z;
      } else if (selectedFreeArrowId) {
        const arrow = freeArrows.find(a => a.id === selectedFreeArrowId);
        if (!arrow) return;
        arrow.z = 1;
      } else if (selectedConnectorId) {
        const conn = connectors.find(c => c.id === selectedConnectorId);
        if (!conn) return;
        conn.z = 1;
      }
      redrawCanvas();
    }

    // =========================
    // Cancella
    // =========================
    function deleteSelected() {
      if (selectedNodeId) {
        const nodeId = selectedNodeId;
        const node = getNodeById(nodeId);
        if (node) node.el.remove();
        nodes = nodes.filter(n => n.id !== nodeId);
        connectors = connectors.filter(c => c.fromId !== nodeId && c.toId !== nodeId);
      } else if (selectedConnectorId) {
        connectors = connectors.filter(c => c.id !== selectedConnectorId);
      } else if (selectedFreeArrowId) {
        freeArrows = freeArrows.filter(a => a.id !== selectedFreeArrowId);
      }
      clearSelection();
      redrawCanvas();
    }

    function clearAll() {
      nodes.forEach(n => n.el.remove());
      nodes = [];
      connectors = [];
      freeArrows = [];
      clearSelection();
      redrawCanvas();
    }

    // =========================
    // Disegno canvas
    // =========================
    function drawArrow(x1, y1, x2, y2, color, isSelected) {
      const headLength = 10;
      const dx = x2 - x1;
      const dy = y2 - y1;
      const angle = Math.atan2(dy, dx);

      ctx.strokeStyle = isSelected ? 'red' : color;
      ctx.fillStyle = isSelected ? 'red' : color;
      ctx.lineWidth = isSelected ? 3 : 2;

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(x2, y2);
      ctx.lineTo(
        x2 - headLength * Math.cos(angle - Math.PI / 6),
        y2 - headLength * Math.sin(angle - Math.PI / 6)
      );
      ctx.lineTo(
        x2 - headLength * Math.cos(angle + Math.PI / 6),
        y2 - headLength * Math.sin(angle + Math.PI / 6)
      );
      ctx.closePath();
      ctx.fill();
    }

    function drawConnector(conn) {
      const fromNode = getNodeById(conn.fromId);
      const toNode = getNodeById(conn.toId);
      if (!fromNode || !toNode) return;
      const p1 = getNodeCenter(fromNode);
      const p2 = getNodeCenter(toNode);
      const isSelected = (conn.id === selectedConnectorId);
      drawArrow(p1.x, p1.y, p2.x, p2.y, conn.color, isSelected);
    }

    function redrawCanvas() {
      ctx.clearRect(0,0,canvas.width, canvas.height);

      const items = [];
      connectors.forEach(c => items.push({type: 'connector', obj: c}));
      freeArrows.forEach(a => items.push({type: 'arrow', obj: a}));

      items.sort((a, b) => (a.obj.z || 0) - (b.obj.z || 0));

      items.forEach(item => {
        if (item.type === 'connector') {
          drawConnector(item.obj);
        } else if (item.type === 'arrow') {
          const a = item.obj;
          const {x1,y1,x2,y2} = getArrowEndpoints(a);
          const isSelected = (a.id === selectedFreeArrowId);
          drawArrow(x1,y1,x2,y2, a.color, isSelected);
        }
      });
    }

    // =========================
    // Export PNG / PDF
    // =========================
    async function saveAsPng() {
      const canvasExport = await html2canvas(workspace);
      const link = document.createElement('a');
      link.href = canvasExport.toDataURL('image/png');
      link.download = 'mindweave-lavagna.png';
      link.click();
    }

    async function saveAsPdf() {
      const canvasExport = await html2canvas(workspace);
      const imgData = canvasExport.toDataURL('image/png');
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF('l', 'pt', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      const ratio = Math.min(pageWidth / canvasExport.width, pageHeight / canvasExport.height);
      const imgWidth = canvasExport.width * ratio;
      const imgHeight = canvasExport.height * ratio;
      const x = (pageWidth - imgWidth) / 2;
      const y = (pageHeight - imgHeight) / 2;
      pdf.addImage(imgData, 'PNG', x, y, imgWidth, imgHeight);
      pdf.save('mindweave-lavagna.pdf');
    }

    // =========================
    // Toolbar
    // =========================
    document.getElementById('addTextBtn').addEventListener('click', addTextNode);
    document.getElementById('toggleWrapBtn').addEventListener('click', toggleWrapSelectedText);

    document.getElementById('addImageBtn').addEventListener('click', () => {
      const fileInput = document.getElementById('imageInput');
      const file = fileInput.files[0];
      addImageNode(file);
      fileInput.value = '';
    });

    document.getElementById('resizeModeBtn').addEventListener('click', () => {
      if (mode === 'resizeNode') setMode('normal');
      else setMode('resizeNode');
    });

    document.getElementById('nodePlusBtn').addEventListener('click', () => {
      scaleSelectedNode(1.1);
    });

    document.getElementById('nodeMinusBtn').addEventListener('click', () => {
      scaleSelectedNode(0.9);
    });

    document.getElementById('connectorModeBtn').addEventListener('click', () => {
      if (mode === 'connector') setMode('normal');
      else {
        clearSelection();
        setMode('connector');
      }
    });

    document.getElementById('arrowModeBtn').addEventListener('click', () => {
      if (mode === 'arrow') {
        setMode('normal');
        drawingArrowStart = null;
      } else {
        clearSelection();
        drawingArrowStart = null;
        setMode('arrow');
      }
    });

    document.getElementById('arrowLengthPlusBtn').addEventListener('click', () => {
      adjustArrowLength(10);
    });

    document.getElementById('arrowLengthMinusBtn').addEventListener('click', () => {
      adjustArrowLength(-10);
    });

    document.getElementById('arrowRotateLeftBtn').addEventListener('click', () => {
      rotateArrow(-5);
    });

    document.getElementById('arrowRotateRightBtn').addEventListener('click', () => {
      rotateArrow(5);
    });

    document.getElementById('borderColorPicker').addEventListener('input', (e) => {
      applyBorderColor(e.target.value);
    });

    document.getElementById('textColorPicker').addEventListener('input', (e) => {
      applyTextColor(e.target.value);
    });

    document.getElementById('arrowColorPicker').addEventListener('input', (e) => {
      applyArrowColor(e.target.value);
    });

    document.getElementById('deleteSelectedBtn').addEventListener('click', deleteSelected);
    document.getElementById('clearAllBtn').addEventListener('click', clearAll);

    document.getElementById('savePngBtn').addEventListener('click', saveAsPng);
    document.getElementById('savePdfBtn').addEventListener('click', saveAsPdf);

    document.getElementById('bringToFrontBtn').addEventListener('click', bringToFront);
    document.getElementById('sendToBackBtn').addEventListener('click', sendToBack);

    // Init
    setMode('normal');
  </script>
</body>
</html>
