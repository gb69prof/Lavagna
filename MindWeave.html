<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>MindWeave</title>

    <!-- Libreria per catturare lo schermo come immagine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Libreria per creare PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: #222;
            color: white;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 10000;
            flex-wrap: wrap;
            font-size: 14px;
        }

        #toolbar input[type="text"] {
            padding: 5px;
            font-size: 14px;
        }

        #toolbar button {
            border: 1px solid #555;
            background: #444;
            color: #fff;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        #toolbar button:hover {
            background: #555;
        }

        #toolbar button.active {
            background: #ffd54f;
            color: #000;
            border-color: #ffb300;
        }

        #toolbar label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        #toolbar input[type="color"] {
            width: 28px;
            height: 22px;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        /* Area di lavoro */
        #workspace {
            position: absolute;
            top: 50px; /* sotto la toolbar */
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none; /* importante per iPad */
        }

        /* CANVAS: frecce sempre davanti; eventi solo quando Freccia ON */
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            pointer-events: none; /* cambiato via JS quando Freccia è ON */
            touch-action: none;
        }

.node {
    position: absolute;
    padding: 8px 14px;
    background: white;
    border: 2px solid #444;
    border-radius: 6px;
    cursor: move;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
    font-size: 16px;
    color: #000;
    
    /* layout interno */
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-align: center;

    /* evita che il testo esploda in orizzontale */
    max-width: 260px;              /* puoi aumentare o ridurre a piacere */
    white-space: normal;
    word-wrap: break-word;
    overflow-wrap: break-word;
    flex-wrap: wrap;

    min-width: 60px;
    min-height: 40px;
    z-index: 3;
}

        .node img {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            object-fit: contain;
            pointer-events: none;
        }

        .node.selected {
            border-color: red;
        }

        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid #333;
            background: #ffd54f;
            box-shadow: 0 0 0 1px #222;
            z-index: 4;
            display: none;
        }

        body.resize-mode-on .node.selected .resize-handle {
            display: block;
        }

        .resize-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nwse-resize;
        }
        .resize-handle.ne {
            top: -6px;
            right: -6px;
            cursor: nesw-resize;
        }
        .resize-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: nwse-resize;
        }
        .resize-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: nesw-resize;
        }

        .node.resizing {
            cursor: nwse-resize;
        }
    </style>
</head>
<body>

<div id="toolbar">
    <input type="text" id="textInput" placeholder="Scrivi un nodo…">
    <button id="addTextBtn">Aggiungi testo</button>

    <input type="file" id="imgInput" accept="image/*">
    <button id="addImgBtn">Aggiungi immagine</button>

    <button id="connectorBtn">Connettore nodi</button>
    <button id="freeArrowBtn">Freccia</button>
    <button id="arrowShorterBtn">Freccia -</button>
    <button id="arrowLongerBtn">Freccia +</button>

    <span style="color:#fff;">Ruota freccia</span>
    <button id="arrowRotateMinusBtn">-</button>
    <button id="arrowRotatePlusBtn">+</button>

    <button id="resizeModeBtn">Ridimensiona nodo</button>
    <button id="nodeSmallerBtn">Nodo -</button>
    <button id="nodeLargerBtn">Nodo +</button>
    <button id="deleteBtn">Cancella</button>

    <label>Bordo
        <input type="color" id="borderColorInput" value="#444444">
    </label>
    <label>Testo
        <input type="color" id="textColorInput" value="#000000">
    </label>
    <label>Freccia
        <input type="color" id="arrowColorInput" value="#333333">
    </label>

    <button id="savePngBtn">Salva PNG</button>
    <button id="savePdfBtn">Salva PDF</button>
    <button id="clearAllBtn">Cancella tutto</button>
</div>

<div id="workspace">
    <canvas id="canvas"></canvas>
</div>

<script>
    const workspace = document.getElementById("workspace");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const textInput = document.getElementById("textInput");
    const imgInput = document.getElementById("imgInput");
    const addTextBtn = document.getElementById("addTextBtn");
    const addImgBtn = document.getElementById("addImgBtn");
    const connectorBtn = document.getElementById("connectorBtn");
    const freeArrowBtn = document.getElementById("freeArrowBtn");
    const arrowShorterBtn = document.getElementById("arrowShorterBtn");
    const arrowLongerBtn = document.getElementById("arrowLongerBtn");
    const arrowRotateMinusBtn = document.getElementById("arrowRotateMinusBtn");
    const arrowRotatePlusBtn = document.getElementById("arrowRotatePlusBtn");
    const resizeModeBtn = document.getElementById("resizeModeBtn");
    const nodeSmallerBtn = document.getElementById("nodeSmallerBtn");
    const nodeLargerBtn = document.getElementById("nodeLargerBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    const borderColorInput = document.getElementById("borderColorInput");
    const textColorInput = document.getElementById("textColorInput");
    const arrowColorInput = document.getElementById("arrowColorInput");

    const savePngBtn = document.getElementById("savePngBtn");
    const savePdfBtn = document.getElementById("savePdfBtn");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const nodes = [];
    let connections = [];   // { from, to, color }
    let freeArrows = [];    // { x1, y1, x2, y2, color }

    let connectorMode = false;
    let freeArrowMode = false;
    let resizeMode = false;

    let freeArrowTempStart = null;

    let selectedNode = null;
    let selectionType = "none";  // "none" | "node" | "connection" | "freeArrow"
    let selectedConnectionIndex = -1;
    let selectedFreeArrowIndex = -1;

    let isResizing = false;
    let currentResizedNode = null;
    let resizeData = null;

    let currentBorderColor = borderColorInput.value;
    let currentTextColor = textColorInput.value;
    let currentArrowColor = arrowColorInput.value;

    // drag nodi
    let nodeDrag = {
        active: false,
        node: null,
        offsetX: 0,
        offsetY: 0,
        startX: 0,
        startY: 0,
        moved: false,
        pointerId: null
    };

    // drag frecce
    let arrowDrag = {
        active: false,
        index: -1,
        lastX: 0,
        lastY: 0,
        pointerId: null
    };

    function resizeCanvas() {
        canvas.width = workspace.clientWidth;
        canvas.height = workspace.clientHeight;
        drawAll();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    function updateCanvasPointerEvents() {
        canvas.style.pointerEvents = freeArrowMode ? "auto" : "none";
    }

    // -- UTILI SELEZIONE --

    function clearNodeSelection() {
        if (selectedNode) {
            selectedNode.classList.remove("selected");
        }
        selectedNode = null;
    }

    function clearConnectionSelection() {
        selectedConnectionIndex = -1;
    }

    function clearFreeArrowSelection() {
        selectedFreeArrowIndex = -1;
    }

    function clearSelection() {
        selectionType = "none";
        clearNodeSelection();
        clearConnectionSelection();
        clearFreeArrowSelection();
        drawAll();
    }

    function applyNodeStyle(node) {
        node.style.borderColor = currentBorderColor;
        node.style.color = currentTextColor;
        node.dataset.borderColor = currentBorderColor;
        node.dataset.textColor = currentTextColor;
    }

    // -- MANIGLIE RIDIMENSIONAMENTO --

    function addResizeHandles(node) {
        const corners = ["nw", "ne", "se", "sw"];
        corners.forEach(corner => {
            const handle = document.createElement("div");
            handle.className = "resize-handle " + corner;
            handle.dataset.corner = corner;

            handle.addEventListener("pointerdown", e => {
                e.stopPropagation();
                e.preventDefault();
                startResize(node, corner, e.clientX, e.clientY);
            });

            node.appendChild(handle);
        });
    }

    function startResize(node, corner, clientX, clientY) {
        if (connectorMode || !resizeMode) return;

        clearSelection();
        selectedNode = node;
        selectionType = "node";
        node.classList.add("selected", "resizing");

        const workspaceRect = workspace.getBoundingClientRect();
        const rect = node.getBoundingClientRect();
        const left = rect.left - workspaceRect.left;
        const top = rect.top - workspaceRect.top;
        const width = rect.width;
        const height = rect.height;

        let aspect = parseFloat(node.dataset.aspectRatio);
        if (!aspect || !isFinite(aspect)) {
            aspect = width / height || 1;
        }

        const computedFontSize = parseFloat(getComputedStyle(node).fontSize) || 16;

        let oppositeX, oppositeY;
        switch (corner) {
            case "se":
                oppositeX = left;
                oppositeY = top;
                break;
            case "sw":
                oppositeX = left + width;
                oppositeY = top;
                break;
            case "ne":
                oppositeX = left;
                oppositeY = top + height;
                break;
            case "nw":
            default:
                oppositeX = left + width;
                oppositeY = top + height;
                break;
        }

        isResizing = true;
        currentResizedNode = node;
        resizeData = {
            corner,
            oppositeX,
            oppositeY,
            aspect,
            minSize: 20,
            initialWidth: width,
            initialFontSize: computedFontSize
        };
    }

    function updateResize(clientX, clientY) {
        if (!isResizing || !currentResizedNode || !resizeData) return;

        const workspaceRect = workspace.getBoundingClientRect();
        const pointerX = clientX - workspaceRect.left;

        const { corner, oppositeX, oppositeY, aspect, minSize, initialWidth, initialFontSize } = resizeData;

        let newWidth = Math.abs(pointerX - oppositeX);
        if (!isFinite(newWidth) || newWidth < minSize) {
            newWidth = minSize;
        }
        const newHeight = newWidth / aspect;

        let newLeft, newTop;
        switch (corner) {
            case "se":
                newLeft = oppositeX;
                newTop = oppositeY;
                break;
            case "sw":
                newLeft = oppositeX - newWidth;
                newTop = oppositeY;
                break;
            case "ne":
                newLeft = oppositeX;
                newTop = oppositeY - newHeight;
                break;
            case "nw":
            default:
                newLeft = oppositeX - newWidth;
                newTop = oppositeY - newHeight;
                break;
        }

        currentResizedNode.style.left = newLeft + "px";
        currentResizedNode.style.top = newTop + "px";
        currentResizedNode.style.width = newWidth + "px";
        currentResizedNode.style.height = newHeight + "px";

        const scaleFactor = newWidth / initialWidth;
        let newFontSize = initialFontSize * scaleFactor;
        if (newFontSize < 8) newFontSize = 8;
        currentResizedNode.style.fontSize = newFontSize + "px";

        drawAll();
    }

    function endResize() {
        if (!isResizing) return;
        isResizing = false;
        if (currentResizedNode) {
            currentResizedNode.classList.remove("resizing");
        }
        currentResizedNode = null;
        resizeData = null;
        drawAll();
    }

    // RIDIMENSIONA NODO CON + / -

    function scaleSelectedNode(factor) {
        if (selectionType !== "node" || !selectedNode) return;

        const workspaceRect = workspace.getBoundingClientRect();
        const rect = selectedNode.getBoundingClientRect();

        const centerX = rect.left - workspaceRect.left + rect.width / 2;
        const centerY = rect.top - workspaceRect.top + rect.height / 2;

        let newWidth = rect.width * factor;
        let newHeight = rect.height * factor;

        const MIN_W = 40;
        const MIN_H = 30;
        if (newWidth < MIN_W) newWidth = MIN_W;
        if (newHeight < MIN_H) newHeight = MIN_H;

        const newLeft = centerX - newWidth / 2;
        const newTop = centerY - newHeight / 2;

        selectedNode.style.left = newLeft + "px";
        selectedNode.style.top = newTop + "px";
        selectedNode.style.width = newWidth + "px";
        selectedNode.style.height = newHeight + "px";

        const currentFontSize = parseFloat(getComputedStyle(selectedNode).fontSize) || 16;
        let newFontSize = currentFontSize * factor;
        if (newFontSize < 8) newFontSize = 8;
        selectedNode.style.fontSize = newFontSize + "px";

        selectedNode.dataset.aspectRatio = newWidth / newHeight;

        drawAll();
    }

    nodeLargerBtn.addEventListener("click", () => scaleSelectedNode(1.1));
    nodeSmallerBtn.addEventListener("click", () => scaleSelectedNode(0.9));

    // -- CREAZIONE NODI --

    addTextBtn.addEventListener("click", addTextNode);
    addImgBtn.addEventListener("click", addImageNode);

    function addTextNode() {
        const text = textInput.value.trim();
        if (!text) return;

        const node = document.createElement("div");
        node.className = "node";
        node.innerText = text;

        positionNode(node);
        applyNodeStyle(node);
        makeDraggable(node);

        workspace.appendChild(node);
        nodes.push(node);

        requestAnimationFrame(() => {
            const rect = node.getBoundingClientRect();
            const ratio = rect.width / rect.height || 1;
            node.dataset.aspectRatio = ratio;
            addResizeHandles(node);
        });
    }

    function addImageNode() {
        const file = imgInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            const node = document.createElement("div");
            node.className = "node";

            const img = document.createElement("img");
            img.src = e.target.result;
            node.appendChild(img);

            positionNode(node);
            applyNodeStyle(node);
            makeDraggable(node);

            workspace.appendChild(node);
            nodes.push(node);

            const setupImageNode = () => {
                const rect = node.getBoundingClientRect();
                const ratio = rect.width / rect.height || 1;
                node.dataset.aspectRatio = ratio;
                addResizeHandles(node);
            };

            if (img.complete) {
                setupImageNode();
            } else {
                img.onload = setupImageNode;
            }
        };
        reader.readAsDataURL(file);
    }

    function positionNode(node) {
        node.style.left = (100 + Math.random() * 300) + "px";
        node.style.top = (50 + Math.random() * 200) + "px";
    }

    // -- DRAG NODI CON POINTER EVENTS --

    function makeDraggable(node) {
        const TAP_THRESHOLD = 5;

        node.addEventListener("pointerdown", e => {
            // se sto lavorando con frecce / resize / connector, non trascino nodi
            if (freeArrowMode || connectorMode || isResizing || arrowDrag.active) return;

            nodeDrag.active = true;
            nodeDrag.node = node;
            nodeDrag.pointerId = e.pointerId;
            const rect = workspace.getBoundingClientRect();
            nodeDrag.startX = e.clientX;
            nodeDrag.startY = e.clientY;
            nodeDrag.offsetX = e.clientX - node.offsetLeft;
            nodeDrag.offsetY = e.clientY - node.offsetTop;
            nodeDrag.moved = false;

            node.setPointerCapture(e.pointerId);
            e.preventDefault();
        });

        node.addEventListener("pointermove", e => {
            if (!nodeDrag.active || nodeDrag.pointerId !== e.pointerId) return;
            const dx = e.clientX - nodeDrag.startX;
            const dy = e.clientY - nodeDrag.startY;
            if (Math.abs(dx) > TAP_THRESHOLD || Math.abs(dy) > TAP_THRESHOLD) {
                nodeDrag.moved = true;
            }
            const newLeft = e.clientX - nodeDrag.offsetX;
            const newTop = e.clientY - nodeDrag.offsetY;
            node.style.left = newLeft + "px";
            node.style.top = newTop + "px";
            drawAll();
        });

        node.addEventListener("pointerup", e => {
            if (!nodeDrag.active || nodeDrag.pointerId !== e.pointerId) return;

            node.releasePointerCapture(e.pointerId);

            if (!nodeDrag.moved) {
                handleNodeClick(node);
            }

            nodeDrag.active = false;
            nodeDrag.node = null;
            nodeDrag.pointerId = null;
        });

        node.addEventListener("pointercancel", () => {
            nodeDrag.active = false;
            nodeDrag.node = null;
            nodeDrag.pointerId = null;
        });
    }

    // -- CLICK SU NODO (SELEZIONE / CONNETTORE) --

    function handleNodeClick(node) {
        if (freeArrowMode) return; // quando lavoriamo con frecce, i nodi stanno zitti

        if (connectorMode) {
            if (!selectedNode) {
                selectedNode = node;
                node.classList.add("selected");
            } else {
                if (node !== selectedNode) {
                    connections.push({
                        from: selectedNode,
                        to: node,
                        color: currentArrowColor
                    });
                }
                selectedNode.classList.remove("selected");
                selectedNode = null;
                connectorMode = false;
                connectorBtn.classList.remove("active");
                drawAll();
            }
            return;
        }

        clearSelection();
        selectedNode = node;
        node.classList.add("selected");
        selectionType = "node";

        if (node.dataset.borderColor) {
            currentBorderColor = node.dataset.borderColor;
            borderColorInput.value = currentBorderColor;
        }
        if (node.dataset.textColor) {
            currentTextColor = node.dataset.textColor;
            textColorInput.value = currentTextColor;
        }
    }

    // -- MODALITÀ CONNETTORE --

    connectorBtn.addEventListener("click", () => {
        connectorMode = !connectorMode;

        if (connectorMode) {
            connectorBtn.classList.add("active");
            resizeMode = false;
            resizeModeBtn.classList.remove("active");
            document.body.classList.remove("resize-mode-on");
            freeArrowMode = false;
            freeArrowBtn.classList.remove("active");
            freeArrowTempStart = null;
            updateCanvasPointerEvents();
            clearSelection();
        } else {
            connectorBtn.classList.remove("active");
            if (selectedNode) {
                selectedNode.classList.remove("selected");
                selectedNode = null;
            }
        }
    });

    // -- MODALITÀ FRECCIA --

    freeArrowBtn.addEventListener("click", () => {
        freeArrowMode = !freeArrowMode;

        if (freeArrowMode) {
            freeArrowBtn.classList.add("active");
            freeArrowTempStart = null;
            connectorMode = false;
            connectorBtn.classList.remove("active");
            resizeMode = false;
            resizeModeBtn.classList.remove("active");
            document.body.classList.remove("resize-mode-on");
            clearSelection();
        } else {
            freeArrowBtn.classList.remove("active");
            freeArrowTempStart = null;
        }
        updateCanvasPointerEvents();
    });

    // -- WORKSPACE CLICK (connessioni, deselezione) --

    workspace.addEventListener("pointerdown", e => {
        if (freeArrowMode) return;
        if (connectorMode) return;
        if (e.target.closest(".node")) return;
        const rect = workspace.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // selezione connessioni
        let foundConnIndex = -1;
        let minDistConn = Infinity;

        connections.forEach((conn, index) => {
            const fromNode = conn.from;
            const toNode = conn.to;
            const x1 = fromNode.offsetLeft + fromNode.offsetWidth / 2;
            const y1 = fromNode.offsetTop + fromNode.offsetHeight / 2;
            const x2 = toNode.offsetLeft + toNode.offsetWidth / 2;
            const y2 = toNode.offsetTop + toNode.offsetHeight / 2;

            const dist = pointToSegmentDistance(x, y, x1, y1, x2, y2);
            if (dist < 10 && dist < minDistConn) {
                minDistConn = dist;
                foundConnIndex = index;
            }
        });

        if (foundConnIndex >= 0) {
            clearSelection();
            selectionType = "connection";
            selectedConnectionIndex = foundConnIndex;
            drawAll();
        } else {
            clearSelection();
        }
    });

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        if (dx === 0 && dy === 0) {
            return Math.hypot(px - x1, py - y1);
        }
        const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
        const clampedT = Math.max(0, Math.min(1, t));
        const cx = x1 + clampedT * dx;
        const cy = y1 + clampedT * dy;
        return Math.hypot(px - cx, py - cy);
    }

    // -- MODALITÀ RIDIMENSIONA NODI --

    resizeModeBtn.addEventListener("click", () => {
        resizeMode = !resizeMode;

        if (resizeMode) {
            resizeModeBtn.classList.add("active");
            document.body.classList.add("resize-mode-on");
            connectorMode = false;
            connectorBtn.classList.remove("active");
            freeArrowMode = false;
            freeArrowBtn.classList.remove("active");
            freeArrowTempStart = null;
            updateCanvasPointerEvents();
        } else {
            resizeModeBtn.classList.remove("active");
            document.body.classList.remove("resize-mode-on");
            endResize();
        }
    });

    // -- ROTAZIONE FRECCIA --

    function rotateSelectedArrowBy(deltaDegrees) {
        if (selectionType !== "freeArrow" || selectedFreeArrowIndex < 0) return;

        const arrow = freeArrows[selectedFreeArrowIndex];
        const rad = deltaDegrees * Math.PI / 180;

        const cx = (arrow.x1 + arrow.x2) / 2;
        const cy = (arrow.y1 + arrow.y2) / 2;

        const dx1 = arrow.x1 - cx;
        const dy1 = arrow.y1 - cy;
        const dx2 = arrow.x2 - cx;
        const dy2 = arrow.y2 - cy;

        const cos = Math.cos(rad);
        const sin = Math.sin(rad);

        const nx1 = dx1 * cos - dy1 * sin;
        const ny1 = dx1 * sin + dy1 * cos;
        const nx2 = dx2 * cos - dy2 * sin;
        const ny2 = dx2 * sin + dy2 * cos;

        arrow.x1 = cx + nx1;
        arrow.y1 = cy + ny1;
        arrow.x2 = cx + nx2;
        arrow.y2 = cy + ny2;

        drawAll();
    }

    arrowRotatePlusBtn.addEventListener("click", () => rotateSelectedArrowBy(5));
    arrowRotateMinusBtn.addEventListener("click", () => rotateSelectedArrowBy(-5));

    // -- RIDIMENSIONA FRECCIA --

    function scaleSelectedArrow(factor) {
        if (selectionType !== "freeArrow" || selectedFreeArrowIndex < 0) return;

        const arrow = freeArrows[selectedFreeArrowIndex];

        const cx = (arrow.x1 + arrow.x2) / 2;
        const cy = (arrow.y1 + arrow.y2) / 2;

        const dx = arrow.x2 - arrow.x1;
        const dy = arrow.y2 - arrow.y1;
        const len = Math.hypot(dx, dy) || 1;

        let newLen = len * factor;
        const MIN_LEN = 20;
        if (newLen < MIN_LEN) newLen = MIN_LEN;

        const ux = dx / len;
        const uy = dy / len;
        const half = newLen / 2;

        arrow.x1 = cx - ux * half;
        arrow.y1 = cy - uy * half;
        arrow.x2 = cx + ux * half;
        arrow.y2 = cy + uy * half;

        drawAll();
    }

    arrowLongerBtn.addEventListener("click", () => scaleSelectedArrow(1.1));
    arrowShorterBtn.addEventListener("click", () => scaleSelectedArrow(0.9));

    // -- COLORI --

    borderColorInput.addEventListener("input", () => {
        currentBorderColor = borderColorInput.value;
        if (selectionType === "node" && selectedNode) {
            applyNodeStyle(selectedNode);
        }
    });

    textColorInput.addEventListener("input", () => {
        currentTextColor = textColorInput.value;
        if (selectionType === "node" && selectedNode) {
            applyNodeStyle(selectedNode);
        }
    });

    arrowColorInput.addEventListener("input", () => {
        currentArrowColor = arrowColorInput.value;
    });

    // -- CANCELLA --

    deleteBtn.addEventListener("click", () => {
        if (selectionType === "node" && selectedNode) {
            connections = connections.filter(conn =>
                conn.from !== selectedNode && conn.to !== selectedNode
            );
            const idx = nodes.indexOf(selectedNode);
            if (idx !== -1) nodes.splice(idx, 1);
            selectedNode.remove();
            clearSelection();
            drawAll();
        } else if (selectionType === "connection" && selectedConnectionIndex >= 0) {
            connections.splice(selectedConnectionIndex, 1);
            clearSelection();
            drawAll();
        } else if (selectionType === "freeArrow" && selectedFreeArrowIndex >= 0) {
            freeArrows.splice(selectedFreeArrowIndex, 1);
            clearSelection();
            drawAll();
        }
    });

    // -- FRECCE GESTITE DAL CANVAS (pointer events) --

    canvas.addEventListener("pointerdown", e => {
        if (!freeArrowMode) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // prima: cerco una freccia vicina per selezionarla/trascinarla
        let nearestIndex = -1;
        let minDist = Infinity;
        freeArrows.forEach((arrow, index) => {
            const dist = pointToSegmentDistance(x, y, arrow.x1, arrow.y1, arrow.x2, arrow.y2);
            if (dist < 10 && dist < minDist) {
                minDist = dist;
                nearestIndex = index;
            }
        });

        if (nearestIndex >= 0) {
            clearSelection();
            selectionType = "freeArrow";
            selectedFreeArrowIndex = nearestIndex;
            arrowDrag.active = true;
            arrowDrag.index = nearestIndex;
            arrowDrag.lastX = x;
            arrowDrag.lastY = y;
            arrowDrag.pointerId = e.pointerId;
            canvas.setPointerCapture(e.pointerId);
            drawAll();
            e.preventDefault();
        } else {
            // nessuna freccia vicina: uso il doppio tocco (start -> end)
            if (!freeArrowTempStart) {
                freeArrowTempStart = { x, y };
            } else {
                const arrow = {
                    x1: freeArrowTempStart.x,
                    y1: freeArrowTempStart.y,
                    x2: x,
                    y2: y,
                    color: currentArrowColor
                };
                freeArrows.push(arrow);
                freeArrowTempStart = null;
                drawAll();
            }
        }
    });

    canvas.addEventListener("pointermove", e => {
        if (!arrowDrag.active || arrowDrag.pointerId !== e.pointerId) return;

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const dx = x - arrowDrag.lastX;
        const dy = y - arrowDrag.lastY;
        arrowDrag.lastX = x;
        arrowDrag.lastY = y;

        const arrow = freeArrows[arrowDrag.index];
        arrow.x1 += dx;
        arrow.y1 += dy;
        arrow.x2 += dx;
        arrow.y2 += dy;

        drawAll();
        e.preventDefault();
    });

    canvas.addEventListener("pointerup", e => {
        if (arrowDrag.active && arrowDrag.pointerId === e.pointerId) {
            canvas.releasePointerCapture(e.pointerId);
            arrowDrag.active = false;
            arrowDrag.index = -1;
            arrowDrag.pointerId = null;
        }
    });

    canvas.addEventListener("pointercancel", () => {
        if (arrowDrag.active && arrowDrag.pointerId != null) {
            canvas.releasePointerCapture(arrowDrag.pointerId);
        }
        arrowDrag.active = false;
        arrowDrag.index = -1;
        arrowDrag.pointerId = null;
    });

    // -- DISEGNO --

    function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // connessioni tra nodi
        connections.forEach((conn, index) => {
            const fromNode = conn.from;
            const toNode = conn.to;

            const fromX = fromNode.offsetLeft + fromNode.offsetWidth / 2;
            const fromY = fromNode.offsetTop + fromNode.offsetHeight / 2;
            const toX = toNode.offsetLeft + toNode.offsetWidth / 2;
            const toY = toNode.offsetTop + toNode.offsetHeight / 2;

            const isSelected =
                selectionType === "connection" && selectedConnectionIndex === index;

            const color = isSelected ? "#ff1744" : conn.color;
            const width = isSelected ? 3 : 2;

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;

            drawArrow(fromX, fromY, toX, toY);
        });

        // frecce libere
        freeArrows.forEach((arrow, index) => {
            const isSelected =
                selectionType === "freeArrow" && selectedFreeArrowIndex === index;

            const color = isSelected ? "#ff1744" : arrow.color;
            const width = isSelected ? 3 : 2;

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;

            drawArrow(arrow.x1, arrow.y1, arrow.x2, arrow.y2);
        });
    }

    function drawArrow(x1, y1, x2, y2) {
        const headLength = 12;
        const angle = Math.atan2(y2 - y1, x2 - x1);

        const lineEndX = x2 - headLength * Math.cos(angle);
        const lineEndY = y2 - headLength * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(lineEndX, lineEndY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(
            x2 - headLength * Math.cos(angle - Math.PI / 6),
            y2 - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
            x2 - headLength * Math.cos(angle + Math.PI / 6),
            y2 - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
    }

    // -- ESPORTAZIONE --

    savePngBtn.addEventListener("click", async () => {
        const canvasCapture = await html2canvas(workspace, {
            backgroundColor: "#ffffff"
        });
        const dataUrl = canvasCapture.toDataURL("image/png");

        const link = document.createElement("a");
        link.href = dataUrl;
        link.download = "mindweave.png";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    savePdfBtn.addEventListener("click", async () => {
        const canvasCapture = await html2canvas(workspace, {
            backgroundColor: "#ffffff"
        });
        const imgData = canvasCapture.toDataURL("image/png");

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: "landscape",
            unit: "pt",
            format: "a4"
        });

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();

        const imgWidth = canvasCapture.width;
        const imgHeight = canvasCapture.height;

        const scale = Math.min(pageWidth / imgWidth, pageHeight / imgHeight);
        const drawWidth = imgWidth * scale;
        const drawHeight = imgHeight * scale;

        const x = (pageWidth - drawWidth) / 2;
        const y = (pageHeight - drawHeight) / 2;

        pdf.addImage(imgData, "PNG", x, y, drawWidth, drawHeight);
        pdf.save("mindweave.pdf");
    });

    // -- CANCELLA TUTTO --

    clearAllBtn.addEventListener("click", () => {
        nodes.forEach(node => node.remove());
        nodes.length = 0;
        connections = [];
        freeArrows = [];
        clearSelection();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    });

    // init
    updateCanvasPointerEvents();
</script>

</body>
</html>
