<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>MindWeave</title>

    <!-- Libreria per catturare lo schermo come immagine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Libreria per creare PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: #222;
            color: white;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 10;
            flex-wrap: wrap;
            font-size: 14px;
        }

        #toolbar input[type="text"] {
            padding: 5px;
            font-size: 14px;
        }

        #toolbar button {
            border: 1px solid #555;
            background: #444;
            color: #fff;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        #toolbar button:hover {
            background: #555;
        }

        #toolbar button.active {
            background: #ffd54f;
            color: #000;
            border-color: #ffb300;
        }

        #toolbar label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        #toolbar input[type="color"] {
            width: 28px;
            height: 22px;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        /* Area di lavoro (canvas + nodi) */
        #workspace {
            position: absolute;
            top: 50px; /* sotto la toolbar */
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none; /* blocca lo scroll / zoom di default su iPad */
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .node {
            position: absolute;
            padding: 8px 14px;
            background: white;
            border: 2px solid #444;
            border-radius: 6px;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none; /* qui si trascina, non si scrolla */
            font-size: 16px;
            color: #000;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-width: 60px;
            min-height: 40px;
        }

        .node img {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            object-fit: contain;
            pointer-events: none; /* trascini il contenitore, non l’immagine */
        }

        .node.selected {
            border-color: red;
        }

        /* Maniglie di ridimensionamento (visibili solo sul nodo selezionato) */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid #333;
            background: #ffd54f;
            box-shadow: 0 0 0 1px #222;
            z-index: 3;
            display: none;
        }

        .node.selected .resize-handle {
            display: block;
        }

        .resize-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nwse-resize;
        }

        .resize-handle.ne {
            top: -6px;
            right: -6px;
            cursor: nesw-resize;
        }

        .resize-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: nwse-resize;
        }

        .resize-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: nesw-resize;
        }

        .node.resizing {
            cursor: nwse-resize;
        }
    </style>
</head>
<body>

<div id="toolbar">
    <input type="text" id="textInput" placeholder="Scrivi un nodo…">
    <button id="addTextBtn">Aggiungi testo</button>

    <input type="file" id="imgInput" accept="image/*">
    <button id="addImgBtn">Aggiungi immagine</button>

    <button id="connectorBtn">Connettore</button>
    <button id="deleteBtn">Cancella</button>

    <label>Bordo
        <input type="color" id="borderColorInput" value="#444444">
    </label>
    <label>Testo
        <input type="color" id="textColorInput" value="#000000">
    </label>
    <label>Freccia
        <input type="color" id="arrowColorInput" value="#333333">
    </label>

    <button id="savePngBtn">Salva PNG</button>
    <button id="savePdfBtn">Salva PDF</button>
    <button id="clearAllBtn">Cancella tutto</button>
</div>

<div id="workspace">
    <canvas id="canvas"></canvas>
</div>

<script>
    const workspace = document.getElementById("workspace");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const textInput = document.getElementById("textInput");
    const imgInput = document.getElementById("imgInput");
    const addTextBtn = document.getElementById("addTextBtn");
    const addImgBtn = document.getElementById("addImgBtn");
    const connectorBtn = document.getElementById("connectorBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    const borderColorInput = document.getElementById("borderColorInput");
    const textColorInput = document.getElementById("textColorInput");
    const arrowColorInput = document.getElementById("arrowColorInput");

    const savePngBtn = document.getElementById("savePngBtn");
    const savePdfBtn = document.getElementById("savePdfBtn");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const nodes = [];
    let connections = []; // ogni connessione: { from, to, color }

    let connectorMode = false;
    let selectedNode = null;             // per nodi (testo o immagine)
    let selectionType = "none";          // "none" | "node" | "connection"
    let selectedConnectionIndex = -1;

    // ridimensionamento
    let isResizing = false;
    let currentResizedNode = null;
    let resizeData = null;

    // colori correnti
    let currentBorderColor = borderColorInput.value;
    let currentTextColor = textColorInput.value;
    let currentArrowColor = arrowColorInput.value;

    function resizeCanvas() {
        canvas.width = workspace.clientWidth;
        canvas.height = workspace.clientHeight;
        drawConnections();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // --- UTILS SELEZIONE ---

    function clearNodeSelection() {
        if (selectedNode) {
            selectedNode.classList.remove("selected");
        }
        selectedNode = null;
    }

    function clearConnectionSelection() {
        selectedConnectionIndex = -1;
    }

    function clearSelection() {
        selectionType = "none";
        clearNodeSelection();
        clearConnectionSelection();
        drawConnections();
    }

    function applyNodeStyle(node) {
        node.style.borderColor = currentBorderColor;
        node.style.color = currentTextColor;
        node.dataset.borderColor = currentBorderColor;
        node.dataset.textColor = currentTextColor;
    }

    // --- MANIGLIE DI RIDIMENSIONAMENTO ---

    function addResizeHandles(node) {
        const corners = ["nw", "ne", "se", "sw"];
        corners.forEach(corner => {
            const handle = document.createElement("div");
            handle.className = "resize-handle " + corner;
            handle.dataset.corner = corner;

            handle.addEventListener("mousedown", e => {
                e.stopPropagation();
                e.preventDefault();
                const { clientX, clientY } = e;
                startResize(node, corner, clientX, clientY);
            });

            handle.addEventListener("touchstart", e => {
                e.stopPropagation();
                e.preventDefault();
                if (e.touches.length > 0) {
                    const t = e.touches[0];
                    startResize(node, corner, t.clientX, t.clientY);
                }
            }, { passive: false });

            node.appendChild(handle);
        });
    }

    function startResize(node, corner, clientX, clientY) {
        if (connectorMode) return;

        clearSelection();
        selectedNode = node;
        selectionType = "node";
        node.classList.add("selected", "resizing");

        const workspaceRect = workspace.getBoundingClientRect();
        const rect = node.getBoundingClientRect();
        const left = rect.left - workspaceRect.left;
        const top = rect.top - workspaceRect.top;
        const width = rect.width;
        const height = rect.height;

        let aspect = parseFloat(node.dataset.aspectRatio);
        if (!aspect || !isFinite(aspect)) {
            aspect = width / height || 1;
        }

        let oppositeX, oppositeY;
        switch (corner) {
            case "se":
                // angolo opposto = top-left
                oppositeX = left;
                oppositeY = top;
                break;
            case "sw":
                // angolo opposto = top-right
                oppositeX = left + width;
                oppositeY = top;
                break;
            case "ne":
                // angolo opposto = bottom-left
                oppositeX = left;
                oppositeY = top + height;
                break;
            case "nw":
            default:
                // angolo opposto = bottom-right
                oppositeX = left + width;
                oppositeY = top + height;
                break;
        }

        isResizing = true;
        currentResizedNode = node;
        resizeData = {
            corner,
            oppositeX,
            oppositeY,
            aspect,
            minSize: 40
        };

        updateResize(clientX, clientY);
    }

    function updateResize(clientX, clientY) {
        if (!isResizing || !currentResizedNode || !resizeData) return;

        const workspaceRect = workspace.getBoundingClientRect();
        const pointerX = clientX - workspaceRect.left;

        const { corner, oppositeX, oppositeY, aspect, minSize } = resizeData;

        let newWidth = Math.abs(pointerX - oppositeX);
        if (!isFinite(newWidth) || newWidth < minSize) {
            newWidth = minSize;
        }
        const newHeight = newWidth / aspect;

        let newLeft, newTop;
        switch (corner) {
            case "se":
                newLeft = oppositeX;
                newTop = oppositeY;
                break;
            case "sw":
                newLeft = oppositeX - newWidth;
                newTop = oppositeY;
                break;
            case "ne":
                newLeft = oppositeX;
                newTop = oppositeY - newHeight;
                break;
            case "nw":
            default:
                newLeft = oppositeX - newWidth;
                newTop = oppositeY - newHeight;
                break;
        }

        currentResizedNode.style.left = newLeft + "px";
        currentResizedNode.style.top = newTop + "px";
        currentResizedNode.style.width = newWidth + "px";
        currentResizedNode.style.height = newHeight + "px";

        drawConnections();
    }

    function endResize() {
        if (!isResizing) return;
        isResizing = false;
        if (currentResizedNode) {
            currentResizedNode.classList.remove("resizing");
        }
        currentResizedNode = null;
        resizeData = null;
        drawConnections();
    }

    // --- CREAZIONE NODI ---

    addTextBtn.addEventListener("click", addTextNode);
    addImgBtn.addEventListener("click", addImageNode);

    function addTextNode() {
        const text = textInput.value.trim();
        if (!text) return;

        const node = document.createElement("div");
        node.className = "node";
        node.innerText = text;

        positionNode(node);
        applyNodeStyle(node);
        makeDraggable(node);

        workspace.appendChild(node);
        nodes.push(node);

        // calcola proporzioni dopo il layout
        requestAnimationFrame(() => {
            const rect = node.getBoundingClientRect();
            const ratio = rect.width / rect.height || 1;
            node.dataset.aspectRatio = ratio;
            addResizeHandles(node);
        });
    }

    function addImageNode() {
        const file = imgInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            const node = document.createElement("div");
            node.className = "node";

            const img = document.createElement("img");
            img.src = e.target.result;
            node.appendChild(img);

            positionNode(node);
            applyNodeStyle(node);
            makeDraggable(node);

            workspace.appendChild(node);
            nodes.push(node);

            const setupImageNode = () => {
                const rect = node.getBoundingClientRect();
                const ratio = rect.width / rect.height || 1;
                node.dataset.aspectRatio = ratio;
                addResizeHandles(node);
            };

            if (img.complete) {
                setupImageNode();
            } else {
                img.onload = setupImageNode;
            }
        };
        reader.readAsDataURL(file);
    }

    function positionNode(node) {
        node.style.left = (100 + Math.random() * 300) + "px";
        node.style.top = (50 + Math.random() * 200) + "px";
    }

    // --- DRAG & DROP NODI (MOUSE + TOUCH), disattivato se connectorMode === true o se sto ridimensionando ---

    function makeDraggable(node) {
        let offsetX = 0;
        let offsetY = 0;
        let isDown = false;
        let startX = 0;
        let startY = 0;
        let hasMoved = false;

        const TAP_THRESHOLD = 5; // px: sotto questo è "tap", sopra è drag

        function startDrag(clientX, clientY) {
            if (connectorMode || isResizing) return;  // in modalità connettore o durante resize NON si trascina
            isDown = true;
            hasMoved = false;
            startX = clientX;
            startY = clientY;
            offsetX = clientX - node.offsetLeft;
            offsetY = clientY - node.offsetTop;
        }

        function moveDrag(clientX, clientY) {
            if (!isDown || connectorMode || isResizing) return;

            const dx = clientX - startX;
            const dy = clientY - startY;
            if (Math.abs(dx) > TAP_THRESHOLD || Math.abs(dy) > TAP_THRESHOLD) {
                hasMoved = true;
            }

            const newLeft = clientX - offsetX;
            const newTop = clientY - offsetY;
            node.style.left = newLeft + "px";
            node.style.top = newTop + "px";
            drawConnections();
        }

        function endDrag(clientX, clientY) {
            if (!isDown) return;
            isDown = false;

            // Se non si è mosso quasi per nulla → tap → selezione
            if (!hasMoved) {
                handleNodeClick(node);
            }
        }

        // mouse
        node.addEventListener("mousedown", e => {
            if (connectorMode || isResizing) return;
            startDrag(e.clientX, e.clientY);
        });

        window.addEventListener("mousemove", e => {
            if (isResizing && currentResizedNode === node) {
                updateResize(e.clientX, e.clientY);
                e.preventDefault();
                return;
            }
            moveDrag(e.clientX, e.clientY);
        });

        window.addEventListener("mouseup", e => {
            if (isResizing && currentResizedNode === node) {
                endResize();
                return;
            }
            endDrag(e.clientX, e.clientY);
        });

        // touch (iPad)
        node.addEventListener("touchstart", e => {
            if (connectorMode) {
                // in modalità connettore il tap verrà gestito in touchend come selezione
                hasMoved = false;
                isDown = false;
                return;
            }
            if (isResizing) return;
            if (e.touches.length > 0) {
                const t = e.touches[0];
                startDrag(t.clientX, t.clientY);
                e.preventDefault(); // blocca scroll/zoom pagina solo in drag
            }
        }, { passive: false });

        window.addEventListener("touchmove", e => {
            if (isResizing && currentResizedNode === node) {
                if (e.touches.length > 0) {
                    const t = e.touches[0];
                    updateResize(t.clientX, t.clientY);
                    e.preventDefault();
                }
                return;
            }
            if (!isDown || connectorMode) return;
            if (e.touches.length > 0) {
                const t = e.touches[0];
                moveDrag(t.clientX, t.clientY);
                e.preventDefault(); // evita scroll durante il drag
            }
        }, { passive: false });

        node.addEventListener("touchend", e => {
            // se siamo in modalità connettore, il tap serve per collegare
            if (connectorMode) {
                handleNodeClick(node);
                return;
            }
            if (isResizing && currentResizedNode === node) {
                endResize();
                return;
            }
            // se eravamo in drag
            if (isDown) {
                const t = (e.changedTouches && e.changedTouches[0]) || null;
                const clientX = t ? t.clientX : startX;
                const clientY = t ? t.clientY : startY;
                endDrag(clientX, clientY);
            } else {
                // touch breve senza drag esplicito → tap
                handleNodeClick(node);
            }
        }, { passive: false });

        window.addEventListener("touchend", () => {
            if (isResizing && currentResizedNode === node) {
                endResize();
            }
            isDown = false;
        });

        window.addEventListener("touchcancel", () => {
            if (isResizing && currentResizedNode === node) {
                endResize();
            }
            isDown = false;
        });

        // click desktop (lasciato per completezza)
        node.addEventListener("click", e => {
            e.stopPropagation();
            handleNodeClick(node);
        });
    }

    // --- MODALITÀ CONNETTORE (TOGGLE) ---

    connectorBtn.addEventListener("click", () => {
        connectorMode = !connectorMode;

        if (connectorMode) {
            connectorBtn.classList.add("active");
            clearSelection();
        } else {
            connectorBtn.classList.remove("active");
            if (selectedNode) {
                selectedNode.classList.remove("selected");
                selectedNode = null;
            }
        }
    });

    function handleNodeClick(node) {
        // Se siamo in modalità connettore: primo nodo = sorgente, secondo = destinazione.
        if (connectorMode) {
            if (!selectedNode) {
                selectedNode = node;
                node.classList.add("selected");
            } else {
                if (node !== selectedNode) {
                    connections.push({
                        from: selectedNode,
                        to: node,
                        color: currentArrowColor
                    });
                }
                selectedNode.classList.remove("selected");
                selectedNode = null;
                connectorMode = false;
                connectorBtn.classList.remove("active");
                drawConnections();
            }
            return;
        }

        // Modalità normale: selezione per colori / cancella
        clearSelection();
        selectedNode = node;
        node.classList.add("selected");
        selectionType = "node";

        // aggiorno i pickers con i colori del nodo selezionato
        if (node.dataset.borderColor) {
            currentBorderColor = node.dataset.borderColor;
            borderColorInput.value = currentBorderColor;
        }
        if (node.dataset.textColor) {
            currentTextColor = node.dataset.textColor;
            textColorInput.value = currentTextColor;
        }
    }

    // --- COLORI NODI E FRECCE ---

    borderColorInput.addEventListener("input", () => {
        currentBorderColor = borderColorInput.value;
        if (selectionType === "node" && selectedNode) {
            applyNodeStyle(selectedNode);
        }
    });

    textColorInput.addEventListener("input", () => {
        currentTextColor = textColorInput.value;
        if (selectionType === "node" && selectedNode) {
            applyNodeStyle(selectedNode);
        }
    });

    arrowColorInput.addEventListener("input", () => {
        currentArrowColor = arrowColorInput.value;
    });

    // --- CANCELLA: elimina nodo o freccia selezionati ---

    deleteBtn.addEventListener("click", () => {
        if (selectionType === "node" && selectedNode) {
            // rimuovi tutte le connessioni legate al nodo
            connections = connections.filter(conn =>
                conn.from !== selectedNode && conn.to !== selectedNode
            );
            // rimuovi nodo dalla lista e dal DOM
            const idx = nodes.indexOf(selectedNode);
            if (idx !== -1) {
                nodes.splice(idx, 1);
            }
            selectedNode.remove();
            clearSelection();
            drawConnections();
        } else if (selectionType === "connection" && selectedConnectionIndex >= 0) {
            connections.splice(selectedConnectionIndex, 1);
            clearSelection();
            drawConnections();
        }
    });

    // --- SELEZIONE FRECCE CON CLICK SU CANVAS ---

    canvas.addEventListener("click", (e) => {
        if (connectorMode) return; // in modalità connettore ignoriamo

        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        let foundIndex = -1;
        let minDist = Infinity;
        connections.forEach((conn, index) => {
            const fromNode = conn.from;
            const toNode = conn.to;

            const x1 = fromNode.offsetLeft + fromNode.offsetWidth / 2;
            const y1 = fromNode.offsetTop + fromNode.offsetHeight / 2;
            const x2 = toNode.offsetLeft + toNode.offsetWidth / 2;
            const y2 = toNode.offsetTop + toNode.offsetHeight / 2;

            const dist = pointToSegmentDistance(x, y, x1, y1, x2, y2);
            if (dist < 10 && dist < minDist) {
                minDist = dist;
                foundIndex = index;
            }
        });

        if (foundIndex >= 0) {
            clearSelection();
            selectionType = "connection";
            selectedConnectionIndex = foundIndex;
            drawConnections();
        } else {
            // click "vuoto": deseleziona tutto
            clearSelection();
        }
    });

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        if (dx === 0 && dy === 0) {
            return Math.hypot(px - x1, py - y1);
        }
        const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
        const clampedT = Math.max(0, Math.min(1, t));
        const cx = x1 + clampedT * dx;
        const cy = y1 + clampedT * dy;
        return Math.hypot(px - cx, py - cy);
    }

    // --- DISEGNO DELLE FRECCE ---

    function drawConnections() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        connections.forEach((conn, index) => {
            const fromNode = conn.from;
            const toNode = conn.to;

            const fromX = fromNode.offsetLeft + fromNode.offsetWidth / 2;
            const fromY = fromNode.offsetTop + fromNode.offsetHeight / 2;
            const toX = toNode.offsetLeft + toNode.offsetWidth / 2;
            const toY = toNode.offsetTop + toNode.offsetHeight / 2;

            const isSelected =
                selectionType === "connection" && selectedConnectionIndex === index;

            const color = isSelected ? "#ff1744" : conn.color;
            const width = isSelected ? 3 : 2;

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;

            drawArrow(fromX, fromY, toX, toY);
        });
    }

    function drawArrow(x1, y1, x2, y2) {
        const headLength = 12;
        const angle = Math.atan2(y2 - y1, x2 - x1);

        const lineEndX = x2 - headLength * Math.cos(angle);
        const lineEndY = y2 - headLength * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(lineEndX, lineEndY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(
            x2 - headLength * Math.cos(angle - Math.PI / 6),
            y2 - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
            x2 - headLength * Math.cos(angle + Math.PI / 6),
            y2 - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
    }

    // --- ESPORTAZIONE: PNG & PDF ---

    savePngBtn.addEventListener("click", async () => {
        const canvasCapture = await html2canvas(workspace, {
            backgroundColor: "#ffffff"
        });
        const dataUrl = canvasCapture.toDataURL("image/png");

        const link = document.createElement("a");
        link.href = dataUrl;
        link.download = "mindweave.png";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    savePdfBtn.addEventListener("click", async () => {
        const canvasCapture = await html2canvas(workspace, {
            backgroundColor: "#ffffff"
        });
        const imgData = canvasCapture.toDataURL("image/png");

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: "landscape",
            unit: "pt",
            format: "a4"
        });

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();

        const imgWidth = canvasCapture.width;
        const imgHeight = canvasCapture.height;

        const scale = Math.min(pageWidth / imgWidth, pageHeight / imgHeight);
        const drawWidth = imgWidth * scale;
        const drawHeight = imgHeight * scale;

        const x = (pageWidth - drawWidth) / 2;
        const y = (pageHeight - drawHeight) / 2;

        pdf.addImage(imgData, "PNG", x, y, drawWidth, drawHeight);
        pdf.save("mindweave.pdf");
    });

    // --- CANCELLA TUTTO ---

    clearAllBtn.addEventListener("click", () => {
        // rimuovi nodi dal DOM
        nodes.forEach(node => node.remove());
        nodes.length = 0;

        // svuota connessioni
        connections = [];

        // azzera selezione
        clearSelection();

        // pulisci canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
</script>

</body>
</html>
