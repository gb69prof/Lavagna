<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <title>MindWeave</title>

    <!-- Libreria per catturare lo schermo come immagine -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <!-- Libreria per creare PDF -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

    <style>
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: sans-serif;
            -webkit-user-select: none;
            user-select: none;
        }

        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            background: #222;
            color: white;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
            z-index: 10000;
            flex-wrap: wrap;
            font-size: 14px;
        }

        #toolbar input[type="text"] {
            padding: 5px;
            font-size: 14px;
        }

        #toolbar button {
            border: 1px solid #555;
            background: #444;
            color: #fff;
            padding: 6px 10px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }

        #toolbar button:hover {
            background: #555;
        }

        #toolbar button.active {
            background: #ffd54f;
            color: #000;
            border-color: #ffb300;
        }

        #toolbar label {
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        #toolbar input[type="color"] {
            width: 28px;
            height: 22px;
            border: none;
            padding: 0;
            cursor: pointer;
        }

        /* Area di lavoro */
        #workspace {
            position: absolute;
            top: 50px; /* sotto la toolbar */
            left: 0;
            right: 0;
            bottom: 0;
            overflow: hidden;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
        }

        /* CANVAS: frecce sempre in primo piano, ma non cattura i click */
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 9999;
            pointer-events: none;
        }

        .node {
            position: absolute;
            padding: 8px 14px;
            background: white;
            border: 2px solid #444;
            border-radius: 6px;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
            font-size: 16px;
            color: #000;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            min-width: 60px;
            min-height: 40px;
            z-index: 3;
        }

        .node img {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            object-fit: contain;
            pointer-events: none;
        }

        .node.selected {
            border-color: red;
        }

        /* Maniglie di ridimensionamento nodi (opzionali) */
        .resize-handle {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            border: 1px solid #333;
            background: #ffd54f;
            box-shadow: 0 0 0 1px #222;
            z-index: 4;
            display: none;
        }

        body.resize-mode-on .node.selected .resize-handle {
            display: block;
        }

        .resize-handle.nw {
            top: -6px;
            left: -6px;
            cursor: nwse-resize;
        }
        .resize-handle.ne {
            top: -6px;
            right: -6px;
            cursor: nesw-resize;
        }
        .resize-handle.se {
            bottom: -6px;
            right: -6px;
            cursor: nwse-resize;
        }
        .resize-handle.sw {
            bottom: -6px;
            left: -6px;
            cursor: nesw-resize;
        }

        .node.resizing {
            cursor: nwse-resize;
        }
    </style>
</head>
<body>

<div id="toolbar">
    <input type="text" id="textInput" placeholder="Scrivi un nodo…">
    <button id="addTextBtn">Aggiungi testo</button>

    <input type="file" id="imgInput" accept="image/*">
    <button id="addImgBtn">Aggiungi immagine</button>

    <button id="connectorBtn">Connettore nodi</button>
    <button id="freeArrowBtn">Freccia</button>
    <button id="arrowShorterBtn">Freccia -</button>
    <button id="arrowLongerBtn">Freccia +</button>

    <span style="color:#fff;">Ruota freccia</span>
    <button id="arrowRotateMinusBtn">-</button>
    <button id="arrowRotatePlusBtn">+</button>

    <button id="resizeModeBtn">Ridimensiona nodo</button>
    <button id="nodeSmallerBtn">Nodo -</button>
    <button id="nodeLargerBtn">Nodo +</button>
    <button id="deleteBtn">Cancella</button>

    <label>Bordo
        <input type="color" id="borderColorInput" value="#444444">
    </label>
    <label>Testo
        <input type="color" id="textColorInput" value="#000000">
    </label>
    <label>Freccia
        <input type="color" id="arrowColorInput" value="#333333">
    </label>

    <button id="savePngBtn">Salva PNG</button>
    <button id="savePdfBtn">Salva PDF</button>
    <button id="clearAllBtn">Cancella tutto</button>
</div>

<div id="workspace">
    <canvas id="canvas"></canvas>
</div>

<script>
    const workspace = document.getElementById("workspace");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    const textInput = document.getElementById("textInput");
    const imgInput = document.getElementById("imgInput");
    const addTextBtn = document.getElementById("addTextBtn");
    const addImgBtn = document.getElementById("addImgBtn");
    const connectorBtn = document.getElementById("connectorBtn");
    const freeArrowBtn = document.getElementById("freeArrowBtn");
    const arrowShorterBtn = document.getElementById("arrowShorterBtn");
    const arrowLongerBtn = document.getElementById("arrowLongerBtn");
    const arrowRotateMinusBtn = document.getElementById("arrowRotateMinusBtn");
    const arrowRotatePlusBtn = document.getElementById("arrowRotatePlusBtn");
    const resizeModeBtn = document.getElementById("resizeModeBtn");
    const nodeSmallerBtn = document.getElementById("nodeSmallerBtn");
    const nodeLargerBtn = document.getElementById("nodeLargerBtn");
    const deleteBtn = document.getElementById("deleteBtn");

    const borderColorInput = document.getElementById("borderColorInput");
    const textColorInput = document.getElementById("textColorInput");
    const arrowColorInput = document.getElementById("arrowColorInput");

    const savePngBtn = document.getElementById("savePngBtn");
    const savePdfBtn = document.getElementById("savePdfBtn");
    const clearAllBtn = document.getElementById("clearAllBtn");

    const nodes = [];
    let connections = [];   // frecce tra nodi: { from, to, color }
    let freeArrows = [];    // frecce libere: { x1, y1, x2, y2, color }

    let connectorMode = false;   // collega nodi
    let freeArrowMode = false;   // crea frecce libere
    let resizeMode = false;      // ridimensiona nodi

    let freeArrowTempStart = null; // punto di partenza freccia libera

    let selectedNode = null;
    let selectionType = "none";  // "none" | "node" | "connection" | "freeArrow"
    let selectedConnectionIndex = -1;
    let selectedFreeArrowIndex = -1;

    // ridimensionamento nodi
    let isResizing = false;
    let currentResizedNode = null;
    let resizeData = null;

    // drag freccia intera
    let arrowMoveDrag = {
        active: false,
        arrowIndex: -1,
        lastX: 0,
        lastY: 0
    };

    // colori correnti
    let currentBorderColor = borderColorInput.value;
    let currentTextColor = textColorInput.value;
    let currentArrowColor = arrowColorInput.value;

    function resizeCanvas() {
        canvas.width = workspace.clientWidth;
        canvas.height = workspace.clientHeight;
        drawAll();
    }

    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // --- UTILS SELEZIONE ---

    function clearNodeSelection() {
        if (selectedNode) {
            selectedNode.classList.remove("selected");
        }
        selectedNode = null;
    }

    function clearConnectionSelection() {
        selectedConnectionIndex = -1;
    }

    function clearFreeArrowSelection() {
        selectedFreeArrowIndex = -1;
    }

    function clearSelection() {
        selectionType = "none";
        clearNodeSelection();
        clearConnectionSelection();
        clearFreeArrowSelection();
        drawAll();
    }

    function applyNodeStyle(node) {
        node.style.borderColor = currentBorderColor;
        node.style.color = currentTextColor;
        node.dataset.borderColor = currentBorderColor;
        node.dataset.textColor = currentTextColor;
    }

    // --- MANIGLIE RIDIMENSIONAMENTO NODI (facoltative) ---

    function addResizeHandles(node) {
        const corners = ["nw", "ne", "se", "sw"];
        corners.forEach(corner => {
            const handle = document.createElement("div");
            handle.className = "resize-handle " + corner;
            handle.dataset.corner = corner;

            handle.addEventListener("mousedown", e => {
                e.stopPropagation();
                e.preventDefault();
                const { clientX, clientY } = e;
                startResize(node, corner, clientX, clientY);
            });

            handle.addEventListener("touchstart", e => {
                e.stopPropagation();
                e.preventDefault();
                if (e.touches.length > 0) {
                    const t = e.touches[0];
                    startResize(node, corner, t.clientX, t.clientY);
                }
            }, { passive: false });

            node.appendChild(handle);
        });
    }

    function startResize(node, corner, clientX, clientY) {
        if (connectorMode || !resizeMode) return;

        clearSelection();
        selectedNode = node;
        selectionType = "node";
        node.classList.add("selected", "resizing");

        const workspaceRect = workspace.getBoundingClientRect();
        const rect = node.getBoundingClientRect();
        const left = rect.left - workspaceRect.left;
        const top = rect.top - workspaceRect.top;
        const width = rect.width;
        const height = rect.height;

        let aspect = parseFloat(node.dataset.aspectRatio);
        if (!aspect || !isFinite(aspect)) {
            aspect = width / height || 1;
        }

        const computedFontSize = parseFloat(getComputedStyle(node).fontSize) || 16;

        let oppositeX, oppositeY;
        switch (corner) {
            case "se":
                oppositeX = left;
                oppositeY = top;
                break;
            case "sw":
                oppositeX = left + width;
                oppositeY = top;
                break;
            case "ne":
                oppositeX = left;
                oppositeY = top + height;
                break;
            case "nw":
            default:
                oppositeX = left + width;
                oppositeY = top + height;
                break;
        }

        isResizing = true;
        currentResizedNode = node;
        resizeData = {
            corner,
            oppositeX,
            oppositeY,
            aspect,
            minSize: 20,
            initialWidth: width,
            initialFontSize: computedFontSize
        };

        updateResize(clientX, clientY);
    }

    function updateResize(clientX, clientY) {
        if (!isResizing || !currentResizedNode || !resizeData) return;

        const workspaceRect = workspace.getBoundingClientRect();
        const pointerX = clientX - workspaceRect.left;

        const { corner, oppositeX, oppositeY, aspect, minSize, initialWidth, initialFontSize } = resizeData;

        let newWidth = Math.abs(pointerX - oppositeX);
        if (!isFinite(newWidth) || newWidth < minSize) {
            newWidth = minSize;
        }
        const newHeight = newWidth / aspect;

        let newLeft, newTop;
        switch (corner) {
            case "se":
                newLeft = oppositeX;
                newTop = oppositeY;
                break;
            case "sw":
                newLeft = oppositeX - newWidth;
                newTop = oppositeY;
                break;
            case "ne":
                newLeft = oppositeX;
                newTop = oppositeY - newHeight;
                break;
            case "nw":
            default:
                newLeft = oppositeX - newWidth;
                newTop = oppositeY - newHeight;
                break;
        }

        currentResizedNode.style.left = newLeft + "px";
        currentResizedNode.style.top = newTop + "px";
        currentResizedNode.style.width = newWidth + "px";
        currentResizedNode.style.height = newHeight + "px";

        const scaleFactor = newWidth / initialWidth;
        let newFontSize = initialFontSize * scaleFactor;
        if (newFontSize < 8) newFontSize = 8;
        currentResizedNode.style.fontSize = newFontSize + "px";

        drawAll();
    }

    function endResize() {
        if (!isResizing) return;
        isResizing = false;
        if (currentResizedNode) {
            currentResizedNode.classList.remove("resizing");
        }
        currentResizedNode = null;
        resizeData = null;
        drawAll();
    }

    // --- RIDIMENSIONAMENTO NODO VIA BOTTONI (iPad friendly) ---

    function scaleSelectedNode(factor) {
        if (selectionType !== "node" || !selectedNode) return;

        const workspaceRect = workspace.getBoundingClientRect();
        const rect = selectedNode.getBoundingClientRect();

        const centerX = rect.left - workspaceRect.left + rect.width / 2;
        const centerY = rect.top - workspaceRect.top + rect.height / 2;

        let newWidth = rect.width * factor;
        let newHeight = rect.height * factor;

        const MIN_W = 40;
        const MIN_H = 30;
        if (newWidth < MIN_W) newWidth = MIN_W;
        if (newHeight < MIN_H) newHeight = MIN_H;

        const newLeft = centerX - newWidth / 2;
        const newTop = centerY - newHeight / 2;

        selectedNode.style.left = newLeft + "px";
        selectedNode.style.top = newTop + "px";
        selectedNode.style.width = newWidth + "px";
        selectedNode.style.height = newHeight + "px";

        const currentFontSize = parseFloat(getComputedStyle(selectedNode).fontSize) || 16;
        let newFontSize = currentFontSize * factor;
        if (newFontSize < 8) newFontSize = 8;
        selectedNode.style.fontSize = newFontSize + "px";

        selectedNode.dataset.aspectRatio = newWidth / newHeight;

        drawAll();
    }

    nodeLargerBtn.addEventListener("click", () => {
        scaleSelectedNode(1.1);
    });

    nodeSmallerBtn.addEventListener("click", () => {
        scaleSelectedNode(0.9);
    });

    // --- CREAZIONE NODI ---

    addTextBtn.addEventListener("click", addTextNode);
    addImgBtn.addEventListener("click", addImageNode);

    function addTextNode() {
        const text = textInput.value.trim();
        if (!text) return;

        const node = document.createElement("div");
        node.className = "node";
        node.innerText = text;

        positionNode(node);
        applyNodeStyle(node);
        makeDraggable(node);

        workspace.appendChild(node);
        nodes.push(node);

        requestAnimationFrame(() => {
            const rect = node.getBoundingClientRect();
            const ratio = rect.width / rect.height || 1;
            node.dataset.aspectRatio = ratio;
            addResizeHandles(node);
        });
    }

    function addImageNode() {
        const file = imgInput.files[0];
        if (!file) return;

        const reader = new FileReader();
        reader.onload = function (e) {
            const node = document.createElement("div");
            node.className = "node";

            const img = document.createElement("img");
            img.src = e.target.result;
            node.appendChild(img);

            positionNode(node);
            applyNodeStyle(node);
            makeDraggable(node);

            workspace.appendChild(node);
            nodes.push(node);

            const setupImageNode = () => {
                const rect = node.getBoundingClientRect();
                const ratio = rect.width / rect.height || 1;
                node.dataset.aspectRatio = ratio;
                addResizeHandles(node);
            };

            if (img.complete) {
                setupImageNode();
            } else {
                img.onload = setupImageNode;
            }
        };
        reader.readAsDataURL(file);
    }

    function positionNode(node) {
        node.style.left = (100 + Math.random() * 300) + "px";
        node.style.top = (50 + Math.random() * 200) + "px";
    }

    // --- DRAG NODI ---

    function makeDraggable(node) {
        let offsetX = 0;
        let offsetY = 0;
        let isDown = false;
        let startX = 0;
        let startY = 0;
        let hasMoved = false;

        const TAP_THRESHOLD = 5;

        function startDrag(clientX, clientY) {
            // se sto collegando, ridimensionando o ho una freccia selezionata → non trascino il nodo
            if (connectorMode || isResizing || resizeMode || arrowMoveDrag.active || selectionType === "freeArrow" || freeArrowMode) return;
            isDown = true;
            hasMoved = false;
            startX = clientX;
            startY = clientY;
            offsetX = clientX - node.offsetLeft;
            offsetY = clientY - node.offsetTop;
        }

        function moveDrag(clientX, clientY) {
            if (!isDown || connectorMode || isResizing || resizeMode || arrowMoveDrag.active) return;

            const dx = clientX - startX;
            const dy = clientY - startY;
            if (Math.abs(dx) > TAP_THRESHOLD || Math.abs(dy) > TAP_THRESHOLD) {
                hasMoved = true;
            }

            const newLeft = clientX - offsetX;
            const newTop = clientY - offsetY;
            node.style.left = newLeft + "px";
            node.style.top = newTop + "px";
            drawAll();
        }

        function endDrag(clientX, clientY) {
            if (!isDown) return;
            isDown = false;

            if (!hasMoved) {
                handleNodeClick(node);
            }
        }

        node.addEventListener("mousedown", e => {
            startDrag(e.clientX, e.clientY);
        });

        window.addEventListener("mousemove", e => {
            if (isResizing && currentResizedNode === node) {
                updateResize(e.clientX, e.clientY);
                e.preventDefault();
                return;
            }
            moveDrag(e.clientX, e.clientY);
        });

        window.addEventListener("mouseup", e => {
            if (isResizing && currentResizedNode === node) {
                endResize();
                return;
            }
            endDrag(e.clientX, e.clientY);
        });

        node.addEventListener("touchstart", e => {
            if (e.touches.length > 0) {
                const t = e.touches[0];
                startDrag(t.clientX, t.clientY);
                e.preventDefault();
            }
        }, { passive: false });

        window.addEventListener("touchmove", e => {
            if (isResizing && currentResizedNode === node) {
                if (e.touches.length > 0) {
                    const t = e.touches[0];
                    updateResize(t.clientX, t.clientY);
                    e.preventDefault();
                }
                return;
            }
            if (!isDown || connectorMode || resizeMode || arrowMoveDrag.active) return;
            if (e.touches.length > 0) {
                const t = e.touches[0];
                moveDrag(t.clientX, t.clientY);
                e.preventDefault();
            }
        }, { passive: false });

        node.addEventListener("touchend", e => {
            if (connectorMode) {
                handleNodeClick(node);
                return;
            }
            if (isResizing && currentResizedNode === node) {
                endResize();
                return;
            }
            if (isDown) {
                const t = (e.changedTouches && e.changedTouches[0]) || null;
                const clientX = t ? t.clientX : startX;
                const clientY = t ? t.clientY : startY;
                endDrag(clientX, clientY);
            } else {
                handleNodeClick(node);
            }
        }, { passive: false });

        window.addEventListener("touchend", () => {
            if (isResizing && currentResizedNode === node) {
                endResize();
            }
            isDown = false;
        });

        window.addEventListener("touchcancel", () => {
            if (isResizing && currentResizedNode === node) {
                endResize();
            }
            isDown = false;
        });

        node.addEventListener("click", e => {
            // NON blocco la propagazione, così il workspace
            // può comunque vedere il click (per selezionare frecce)
            handleNodeClick(node);
        });
    }

    // --- MODALITÀ CONNETTORE NODI ---

    connectorBtn.addEventListener("click", () => {
        connectorMode = !connectorMode;

        if (connectorMode) {
            connectorBtn.classList.add("active");
            resizeMode = false;
            resizeModeBtn.classList.remove("active");
            document.body.classList.remove("resize-mode-on");
            freeArrowMode = false;
            freeArrowBtn.classList.remove("active");
            freeArrowTempStart = null;
            clearSelection();
        } else {
            connectorBtn.classList.remove("active");
            if (selectedNode) {
                selectedNode.classList.remove("selected");
                selectedNode = null;
            }
        }
    });

    // --- MODALITÀ FRECCIA LIBERA (CREAZIONE) ---

    freeArrowBtn.addEventListener("click", () => {
        freeArrowMode = !freeArrowMode;

        if (freeArrowMode) {
            freeArrowBtn.classList.add("active");
            freeArrowTempStart = null;
            connectorMode = false;
            connectorBtn.classList.remove("active");
            resizeMode = false;
            resizeModeBtn.classList.remove("active");
            document.body.classList.remove("resize-mode-on");
            clearSelection();
        } else {
            freeArrowBtn.classList.remove("active");
            freeArrowTempStart = null;
        }
    });

    // CLICK SUL WORKSPACE:
    // - se freccia libera attiva → crea freccia (anche cliccando sull'immagine)
    // - altrimenti → seleziona frecce / connessioni (anche sopra i nodi)

    workspace.addEventListener("click", (e) => {
        const rect = workspace.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        // CREA FRECCIA LIBERA OVUNQUE
        if (freeArrowMode) {
            if (!freeArrowTempStart) {
                freeArrowTempStart = { x, y };
            } else {
                const arrow = {
                    x1: freeArrowTempStart.x,
                    y1: freeArrowTempStart.y,
                    x2: x,
                    y2: y,
                    color: currentArrowColor
                };
                freeArrows.push(arrow);
                freeArrowTempStart = null;
                drawAll();
            }
            return;
        }

        // in modalità connettore gestiamo solo con i click sui nodi
        if (connectorMode) return;

        const clickedNode = e.target.closest(".node");

        let foundFreeIndex = -1;
        let foundConnIndex = -1;
        let minDistFree = Infinity;
        let minDistConn = Infinity;

        // frecce libere
        freeArrows.forEach((arrow, index) => {
            const dist = pointToSegmentDistance(x, y, arrow.x1, arrow.y1, arrow.x2, arrow.y2);
            if (dist < 10 && dist < minDistFree) {
                minDistFree = dist;
                foundFreeIndex = index;
            }
        });

        // connessioni tra nodi
        connections.forEach((conn, index) => {
            const fromNode = conn.from;
            const toNode = conn.to;

            const x1 = fromNode.offsetLeft + fromNode.offsetWidth / 2;
            const y1 = fromNode.offsetTop + fromNode.offsetHeight / 2;
            const x2 = toNode.offsetLeft + toNode.offsetWidth / 2;
            const y2 = toNode.offsetTop + toNode.offsetHeight / 2;

            const dist = pointToSegmentDistance(x, y, x1, y1, x2, y2);
            if (dist < 10 && dist < minDistConn) {
                minDistConn = dist;
                foundConnIndex = index;
            }
        });

        if (foundFreeIndex >= 0) {
            clearSelection();
            selectionType = "freeArrow";
            selectedFreeArrowIndex = foundFreeIndex;
            drawAll();
        } else if (foundConnIndex >= 0) {
            clearSelection();
            selectionType = "connection";
            selectedConnectionIndex = foundConnIndex;
            drawAll();
        } else {
            // se clicco sul vuoto → pulisco la selezione
            // se clicco su un nodo e non c'è freccia → lascio la selezione del nodo
            if (!clickedNode) {
                clearSelection();
            }
        }
    });

    function pointToSegmentDistance(px, py, x1, y1, x2, y2) {
        const dx = x2 - x1;
        const dy = y2 - y1;
        if (dx === 0 && dy === 0) {
            return Math.hypot(px - x1, py - y1);
        }
        const t = ((px - x1) * dx + (py - y1) * dy) / (dx * dx + dy * dy);
        const clampedT = Math.max(0, Math.min(1, t));
        const cx = x1 + clampedT * dx;
        const cy = y1 + clampedT * dy;
        return Math.hypot(px - cx, py - cy);
    }

    // --- MODALITÀ RIDIMENSIONA NODI ---

    resizeModeBtn.addEventListener("click", () => {
        resizeMode = !resizeMode;

        if (resizeMode) {
            resizeModeBtn.classList.add("active");
            document.body.classList.add("resize-mode-on");

            connectorMode = false;
            connectorBtn.classList.remove("active");
            freeArrowMode = false;
            freeArrowBtn.classList.remove("active");
            freeArrowTempStart = null;
        } else {
            resizeModeBtn.classList.remove("active");
            document.body.classList.remove("resize-mode-on");
            endResize();
        }
    });

    // --- ROTAZIONE FRECCIA CON BOTTONI +/- (5°) ---

    function rotateSelectedArrowBy(deltaDegrees) {
        if (selectionType !== "freeArrow" || selectedFreeArrowIndex < 0) return;

        const arrow = freeArrows[selectedFreeArrowIndex];
        const rad = deltaDegrees * Math.PI / 180;

        const cx = (arrow.x1 + arrow.x2) / 2;
        const cy = (arrow.y1 + arrow.y2) / 2;

        const dx1 = arrow.x1 - cx;
        const dy1 = arrow.y1 - cy;
        const dx2 = arrow.x2 - cx;
        const dy2 = arrow.y2 - cy;

        const cos = Math.cos(rad);
        const sin = Math.sin(rad);

        const nx1 = dx1 * cos - dy1 * sin;
        const ny1 = dx1 * sin + dy1 * cos;
        const nx2 = dx2 * cos - dy2 * sin;
        const ny2 = dx2 * sin + dy2 * cos;

        arrow.x1 = cx + nx1;
        arrow.y1 = cy + ny1;
        arrow.x2 = cx + nx2;
        arrow.y2 = cy + ny2;

        drawAll();
    }

    arrowRotatePlusBtn.addEventListener("click", () => {
        rotateSelectedArrowBy(5); // senso orario
    });

    arrowRotateMinusBtn.addEventListener("click", () => {
        rotateSelectedArrowBy(-5); // senso antiorario
    });

    // --- RIDIMENSIONAMENTO FRECCIA CON BOTTONI (Freccia - / Freccia +) ---

    function scaleSelectedArrow(factor) {
        if (selectionType !== "freeArrow" || selectedFreeArrowIndex < 0) return;

        const arrow = freeArrows[selectedFreeArrowIndex];

        const cx = (arrow.x1 + arrow.x2) / 2;
        const cy = (arrow.y1 + arrow.y2) / 2;

        const dx = arrow.x2 - arrow.x1;
        const dy = arrow.y2 - arrow.y1;
        const len = Math.hypot(dx, dy) || 1;

        let newLen = len * factor;
        const MIN_LEN = 20;
        if (newLen < MIN_LEN) newLen = MIN_LEN;

        const ux = dx / len;
        const uy = dy / len;
        const half = newLen / 2;

        arrow.x1 = cx - ux * half;
        arrow.y1 = cy - uy * half;
        arrow.x2 = cx + ux * half;
        arrow.y2 = cy + uy * half;

        drawAll();
    }

    arrowLongerBtn.addEventListener("click", () => {
        scaleSelectedArrow(1.1);
    });

    arrowShorterBtn.addEventListener("click", () => {
        scaleSelectedArrow(0.9);
    });

    // --- CLICK SUI NODI ---

    function handleNodeClick(node) {
        // se sto creando frecce libere non seleziono il nodo
        if (freeArrowMode) return;

        if (connectorMode) {
            if (!selectedNode) {
                selectedNode = node;
                node.classList.add("selected");
            } else {
                if (node !== selectedNode) {
                    connections.push({
                        from: selectedNode,
                        to: node,
                        color: currentArrowColor
                    });
                }
                selectedNode.classList.remove("selected");
                selectedNode = null;
                connectorMode = false;
                connectorBtn.classList.remove("active");
                drawAll();
            }
            return;
        }

        clearSelection();
        selectedNode = node;
        node.classList.add("selected");
        selectionType = "node";

        if (node.dataset.borderColor) {
            currentBorderColor = node.dataset.borderColor;
            borderColorInput.value = currentBorderColor;
        }
        if (node.dataset.textColor) {
            currentTextColor = node.dataset.textColor;
            textColorInput.value = currentTextColor;
        }
    }

    // --- COLORI NODI E FRECCE ---

    borderColorInput.addEventListener("input", () => {
        currentBorderColor = borderColorInput.value;
        if (selectionType === "node" && selectedNode) {
            applyNodeStyle(selectedNode);
        }
    });

    textColorInput.addEventListener("input", () => {
        currentTextColor = textColorInput.value;
        if (selectionType === "node" && selectedNode) {
            applyNodeStyle(selectedNode);
        }
    });

    arrowColorInput.addEventListener("input", () => {
        currentArrowColor = arrowColorInput.value;
    });

    // --- CANCELLA ---

    deleteBtn.addEventListener("click", () => {
        if (selectionType === "node" && selectedNode) {
            connections = connections.filter(conn =>
                conn.from !== selectedNode && conn.to !== selectedNode
            );
            const idx = nodes.indexOf(selectedNode);
            if (idx !== -1) {
                nodes.splice(idx, 1);
            }
            selectedNode.remove();
            clearSelection();
            drawAll();
        } else if (selectionType === "connection" && selectedConnectionIndex >= 0) {
            connections.splice(selectedConnectionIndex, 1);
            clearSelection();
            drawAll();
        } else if (selectionType === "freeArrow" && selectedFreeArrowIndex >= 0) {
            freeArrows.splice(selectedFreeArrowIndex, 1);
            clearSelection();
            drawAll();
        }
    });

    // --- DRAG FRECCIA INTERA (anche sopra l'immagine) ---

    workspace.addEventListener("mousedown", (e) => {
        if (selectionType !== "freeArrow" || selectedFreeArrowIndex < 0) return;
        if (freeArrowMode || connectorMode) return;

        const rect = workspace.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const arrow = freeArrows[selectedFreeArrowIndex];
        const dist = pointToSegmentDistance(x, y, arrow.x1, arrow.y1, arrow.x2, arrow.y2);

        if (dist < 10) {
            arrowMoveDrag.active = true;
            arrowMoveDrag.arrowIndex = selectedFreeArrowIndex;
            arrowMoveDrag.lastX = x;
            arrowMoveDrag.lastY = y;
            e.preventDefault();
        }
    });

    workspace.addEventListener("touchstart", (e) => {
        if (selectionType !== "freeArrow" || selectedFreeArrowIndex < 0) return;
        if (freeArrowMode || connectorMode) return;
        if (e.touches.length === 0) return;

        const rect = workspace.getBoundingClientRect();
        const t = e.touches[0];
        const x = t.clientX - rect.left;
        const y = t.clientY - rect.top;

        const arrow = freeArrows[selectedFreeArrowIndex];
        const dist = pointToSegmentDistance(x, y, arrow.x1, arrow.y1, arrow.x2, arrow.y2);

        if (dist < 10) {
            arrowMoveDrag.active = true;
            arrowMoveDrag.arrowIndex = selectedFreeArrowIndex;
            arrowMoveDrag.lastX = x;
            arrowMoveDrag.lastY = y;
            e.preventDefault();
        }
    }, { passive: false });

    function moveWholeArrow(clientX, clientY) {
        if (!arrowMoveDrag.active || arrowMoveDrag.arrowIndex < 0) return;

        const rect = workspace.getBoundingClientRect();
        const x = clientX - rect.left;
        const y = clientY - rect.top;

        const dx = x - arrowMoveDrag.lastX;
        const dy = y - arrowMoveDrag.lastY;
        arrowMoveDrag.lastX = x;
        arrowMoveDrag.lastY = y;

        const arrow = freeArrows[arrowMoveDrag.arrowIndex];
        arrow.x1 += dx;
        arrow.y1 += dy;
        arrow.x2 += dx;
        arrow.y2 += dy;

        drawAll();
    }

    window.addEventListener("mousemove", e => {
        if (arrowMoveDrag.active) {
            e.preventDefault();
            moveWholeArrow(e.clientX, e.clientY);
        } else if (isResizing && currentResizedNode) {
            updateResize(e.clientX, e.clientY);
            e.preventDefault();
        }
    });

    window.addEventListener("mouseup", () => {
        if (arrowMoveDrag.active) {
            arrowMoveDrag.active = false;
        }
        if (isResizing) {
            endResize();
        }
    });

    window.addEventListener("touchmove", e => {
        if (arrowMoveDrag.active) {
            if (e.touches.length > 0) {
                const t = e.touches[0];
                moveWholeArrow(t.clientX, t.clientY);
                e.preventDefault();
            }
        } else if (isResizing && currentResizedNode && e.touches.length > 0) {
            const t = e.touches[0];
            updateResize(t.clientX, t.clientY);
            e.preventDefault();
        }
    }, { passive: false });

    window.addEventListener("touchend", () => {
        if (arrowMoveDrag.active) {
            arrowMoveDrag.active = false;
        }
        if (isResizing) {
            endResize();
        }
    });

    window.addEventListener("touchcancel", () => {
        if (arrowMoveDrag.active) {
            arrowMoveDrag.active = false;
        }
        if (isResizing) {
            endResize();
        }
    });

    // --- DISEGNO COMPLETO ---

    function drawAll() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // connessioni tra nodi
        connections.forEach((conn, index) => {
            const fromNode = conn.from;
            const toNode = conn.to;

            const fromX = fromNode.offsetLeft + fromNode.offsetWidth / 2;
            const fromY = fromNode.offsetTop + fromNode.offsetHeight / 2;
            const toX = toNode.offsetLeft + toNode.offsetWidth / 2;
            const toY = toNode.offsetTop + toNode.offsetHeight / 2;

            const isSelected =
                selectionType === "connection" && selectedConnectionIndex === index;

            const color = isSelected ? "#ff1744" : conn.color;
            const width = isSelected ? 3 : 2;

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;

            drawArrow(fromX, fromY, toX, toY);
        });

        // frecce libere
        freeArrows.forEach((arrow, index) => {
            const isSelected =
                selectionType === "freeArrow" && selectedFreeArrowIndex === index;

            const color = isSelected ? "#ff1744" : arrow.color;
            const width = isSelected ? 3 : 2;

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;

            drawArrow(arrow.x1, arrow.y1, arrow.x2, arrow.y2);
        });
    }

    function drawArrow(x1, y1, x2, y2) {
        const headLength = 12;
        const angle = Math.atan2(y2 - y1, x2 - x1);

        const lineEndX = x2 - headLength * Math.cos(angle);
        const lineEndY = y2 - headLength * Math.sin(angle);

        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(lineEndX, lineEndY);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(x2, y2);
        ctx.lineTo(
            x2 - headLength * Math.cos(angle - Math.PI / 6),
            y2 - headLength * Math.sin(angle - Math.PI / 6)
        );
        ctx.lineTo(
            x2 - headLength * Math.cos(angle + Math.PI / 6),
            y2 - headLength * Math.sin(angle + Math.PI / 6)
        );
        ctx.closePath();
        ctx.fill();
    }

    // --- ESPORTAZIONE PNG & PDF ---

    savePngBtn.addEventListener("click", async () => {
        const canvasCapture = await html2canvas(workspace, {
            backgroundColor: "#ffffff"
        });
        const dataUrl = canvasCapture.toDataURL("image/png");

        const link = document.createElement("a");
        link.href = dataUrl;
        link.download = "mindweave.png";
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    savePdfBtn.addEventListener("click", async () => {
        const canvasCapture = await html2canvas(workspace, {
            backgroundColor: "#ffffff"
        });
        const imgData = canvasCapture.toDataURL("image/png");

        const { jsPDF } = window.jspdf;
        const pdf = new jsPDF({
            orientation: "landscape",
            unit: "pt",
            format: "a4"
        });

        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();

        const imgWidth = canvasCapture.width;
        const imgHeight = canvasCapture.height;

        const scale = Math.min(pageWidth / imgWidth, pageHeight / imgHeight);
        const drawWidth = imgWidth * scale;
        const drawHeight = imgHeight * scale;

        const x = (pageWidth - drawWidth) / 2;
        const y = (pageHeight - drawHeight) / 2;

        pdf.addImage(imgData, "PNG", x, y, drawWidth, drawHeight);
        pdf.save("mindweave.pdf");
    });

    // --- CANCELLA TUTTO ---

    clearAllBtn.addEventListener("click", () => {
        nodes.forEach(node => node.remove());
        nodes.length = 0;
        connections = [];
        freeArrows = [];
        clearSelection();
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    });
</script>

</body>
</html>
